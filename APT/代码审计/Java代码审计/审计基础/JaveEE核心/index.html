<!-- build time:Thu Jan 18 2024 13:22:56 GMT+0800 (China Standard Time) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="余星酒" href="http://example.com/rss.xml"><link rel="alternate" type="application/atom+xml" title="余星酒" href="http://example.com/atom.xml"><link rel="alternate" type="application/json" title="余星酒" href="http://example.com/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="Java代码审计,Java安全基础篇"><link rel="canonical" href="http://example.com/APT/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/%E5%AE%A1%E8%AE%A1%E5%9F%BA%E7%A1%80/JaveEE%E6%A0%B8%E5%BF%83/"><title>10. JaveEE核心 - Java安全基础 - 代码审计 | 余星酒 = 余星酒 = 痴看年少风雨疾，一转本生蹉跎游</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">10. JaveEE核心</h1><div class="meta"><span class="item" title="创建时间：2023-07-15 19:11:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2023-07-15T19:11:00+08:00">2023-07-15</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">余星酒</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gicli9lfebj20zk0m84qp.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giclx6phq6j20zk0m8e36.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gicitcxhpij20zk0m8hdt.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipexe4oykj20zk0m87ji.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gicljitigmj20zk0m87fp.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giclh3brzpj20zk0m8ann.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/" itemprop="item" rel="index" title="分类于 代码审计"><span itemprop="name">代码审计</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/Java%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/" itemprop="item" rel="index" title="分类于 Java安全基础"><span itemprop="name">Java安全基础</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/APT/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/%E5%AE%A1%E8%AE%A1%E5%9F%BA%E7%A1%80/JaveEE%E6%A0%B8%E5%BF%83/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="余星酒"><meta itemprop="description" content="痴看年少风雨疾，一转本生蹉跎游, 欢迎参观我的笔记空间 ~ 这里主要会记录一些安全相关的学习笔记 🌸"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="余星酒"></span><div class="body md" itemprop="articleBody"><h1 id="JavaEE分层模型"><a href="#JavaEE分层模型" class="headerlink" title="JavaEE分层模型"></a>JavaEE分层模型</h1><h2 id="JavaEE的核心技术"><a href="#JavaEE的核心技术" class="headerlink" title="JavaEE的核心技术"></a>JavaEE的核心技术</h2><blockquote><p>包括<code>JDBC</code>、<code>JNDI</code>、<code>EJB</code>、<code>RMI</code>、<code>Servlet</code>、<code>JSP</code>、<code>XML</code>、<code>JMS</code>、<code>JavaIDL</code>、<code>JTS</code>、<code>JTA</code>、<code>JavaMail</code>和<code>JAF</code></p></blockquote><ol><li><p>Java数据库连接 <code>Java Database Connectivity =&gt; JDBC</code> 在java语言中用来规范客户端程序如何访问数据库的应用程序接口，提供了诸如查询和更新数据库中数据的方法</p></li><li><p>Java命名和目录接口 <code>Java Naming and Directory Interface =&gt; JNDI</code> 是java的一个目录服务应用程序界面（API）提供了一个目录系统，并将服务名称与对象关联起来，从而是开发人员在开发过程中可以用名称来访问对象</p></li><li><p>企业级JavaBean <code>Enterprise JavaBean =&gt; EJB</code> 是一个用来构筑企业级应用的、在服务器端可被管理的组件</p></li><li><p>远程方法调用 <code>Remot Method Invocation =&gt; RMI</code> 是Java的一组拥护开发分布式应用程序的API，增强了Java开发分布式应用的能力</p></li><li><p><code>JavaServer Pages =&gt; JSP</code> Sun公司主导并创建的一种动态网页技术标准</p></li><li><p>Java消息服务 <code>Java Message Service =&gt; JMS</code> 是一个Java平台中关于面向消息中间件（MOM）的API，用于正在两个应用程序之间或分布式系统中发送消息，进行异步通信</p></li></ol><h2 id="JavaEE分层"><a href="#JavaEE分层" class="headerlink" title="JavaEE分层"></a>JavaEE分层</h2><ol><li>Domain Object（领域对象）层 ：由一系列POJO（普通的、传统的Java对象）组成，这些对象是该系统的Domain Object通常包含各自所需实现的业务逻辑方法</li><li>DAO（数据访问对象）层 ：由一系列DAO组件组成，这些DAO实现了对数据库的增删改查等操作</li><li>Service（业务逻辑）层 ：由一系列的业务逻辑对象组成，这些业务逻辑对象实现了系统所需要的业务逻辑方法</li><li>Controller（控制器）层 ：由一系列控制器组成，这些控制器用于拦截用户的请求，并调用业务逻辑组件的方法去处理用户请求，然后根据结果向不同的View组件转发</li><li>View（表现）层 ：由一系列页面及视图组件组成，负责收集用户请求，并显示处理后的结果</li></ol><p><img data-src="/JavaEE%E6%A0%B8%E5%BF%83/image-20230711113716062.png" alt="image-20230711113716062"></p><h1 id="MVC模式与MVC框架"><a href="#MVC模式与MVC框架" class="headerlink" title="MVC模式与MVC框架"></a>MVC模式与MVC框架</h1><p>M（module）指数据模型 ：表示携带数据的对象或Java POJO，即使模型内的数据改变，它也具有逻辑来更新控制器</p><p>V（view）指用户界面 ：表示模型包含的数据的可视化层</p><p>C（controller）指控制器 ：表示逻辑控制，控制器对模型和视图都有作用，控制数据流进入模型对象，并在数据更改时更新视图，是视图和模型的中间层</p><p>MVC是一个设计模式，强制性地使应用程序的 <code>输入</code>、<code>处理</code>、<code>输出</code> 分开，独立处理各自的任务</p><p><img data-src="/JavaEE%E6%A0%B8%E5%BF%83/image-20230711114610100-1689047176315-1.png" alt="image-20230711114610100"></p><h2 id="Java-MVC框架"><a href="#Java-MVC框架" class="headerlink" title="Java MVC框架"></a>Java MVC框架</h2><blockquote><p>经典的<code>Struts1</code>、<code>Struts2</code>、<code>Spring MVC</code> 还有小众的JSF框架以及Tapestry框架</p></blockquote><ol><li>Struts1框架 ：较早的Java开源框架之一，基于MVC模式定义了通用的Controller，通过配置文件分离了Model和View，通过Action对用户请求进行了封装</li><li>Struts2框架 ：Struts2框架不是单纯由Struts1版本升级来的，而是Apache根据WebWork的项目发展而来，同样是基于MVC设计模式的web应用框架，本质上相当于一个Servlet，在MVC设计模式中，Struts2作为控制器来建立模型与视图的数据交互</li><li>Spring MVC框架 ：Spring MVC是一个基于MVC思想的优秀应用框架，是Spring的一个子框架</li><li>JSF框架 ：JSF框架是一个用于构建Java Web应用程序的标准框架，也是一个MVC Web应用框架，它提供了一种以组件为中心的用户界面（UI）构建方法</li><li>Tapestry框架 ：它并不是一种单纯的MVC框架，更像MVC框架和模板技术的结合，不仅包含前段MVC框架，还包含一种视图层的模板技术</li></ol><h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><p>Servlet其实是在Java Web容器中运行的小程序，用户通常使用Servlet来处理一些较为复杂的服务器端的业务逻辑，Servlet原则上可以通过任何客户端-服务器协议进行通信，但是常用来与HTTP一起使用，Servlet是JavaEE的核心，也是所有MVC框架实现的根本</p><h2 id="Servlet配置"><a href="#Servlet配置" class="headerlink" title="Servlet配置"></a>Servlet配置</h2><p>版本不同，Servlet的配置也不同，Servlet3.0之前的版本都是在<code>web.xml</code>中配置的，而Servlet3.0之后则通过注解的方式来配置</p><p><img data-src="/JavaEE%E6%A0%B8%E5%BF%83/image-20230711175341847.png" alt="image-20230711175341847"></p><h2 id="基于web-xml配置"><a href="#基于web-xml配置" class="headerlink" title="基于web.xml配置"></a>基于web.xml配置</h2><p><img data-src="/JavaEE%E6%A0%B8%E5%BF%83/image-20230711175456376.png" alt="image-20230711175456376"></p><p>在web.xml中，Servlet的配置在Servlet标签中，Servlet标签是由<code>Servlet</code>和<code>Servlet-mapping</code>标签组成，两者通过标签中相同的<code>Servlet-name</code>名称实现关联</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>&lt;servlet&gt;</td><td>声明Servlet配置入口</td></tr><tr><td>&lt;description&gt;</td><td>声明Servlet描述信息</td></tr><tr><td>&lt;display-name&gt;</td><td>定义web应用的名字</td></tr><tr><td>&lt;servlet-name&gt;</td><td>声明Servlet名称以便后面的映射时使用</td></tr><tr><td>&lt;servlet-class&gt;</td><td>指定当前servlet对应的类的路径</td></tr><tr><td>&lt;servlety-mapping&gt;</td><td>注册组件访问配置的路径入口</td></tr><tr><td>&lt;servlet-name&gt;</td><td>指定上文配置的Servlet的名称</td></tr><tr><td>&lt;url-pattern&gt;</td><td>指定配置这个组件的访问路径</td></tr></tbody></table><h2 id="基于注解方式"><a href="#基于注解方式" class="headerlink" title="基于注解方式"></a>基于注解方式</h2><p>Servlet3.0以上的版本中，开发者无须在web.xml里面配置Servlet，只需要添加<code>@WebServlet</code>注解即可修改Servlet的属性</p><p><img data-src="/JavaEE%E6%A0%B8%E5%BF%83/image-20230711181044714.png" alt="image-20230711181044714"></p><p>可以看到第13行<code>@WebServlet</code>的注解参数有<code>description</code>和<code>urlPatterns</code></p><p><img data-src="/JavaEE%E6%A0%B8%E5%BF%83/image-20230711181247077.png" alt="image-20230711181247077"></p><h2 id="Servlet访问流程"><a href="#Servlet访问流程" class="headerlink" title="Servlet访问流程"></a>Servlet访问流程</h2><blockquote><p>以<code>web.xml</code>为例</p></blockquote><p><img data-src="/JavaEE%E6%A0%B8%E5%BF%83/image-20230711181311932.png" alt="image-20230711181311932"></p><ol><li>首先在浏览器地址栏中输入<code>user</code>即访问<code>url-pattern</code>标签中的值</li><li>浏览器发起请求，服务器通过<code>servlet-mapping</code>标签中找到文件名为<code>user</code>的<code>url-pattern</code>，通过其对应的<code>servlet-name</code>寻找servlet标签中<code>servlet-name</code>相同的<code>servlet</code></li><li>再通过<code>servlet</code>标签中的<code>servlet-name</code>获取<code>servlet-class</code>参数，最后得到具体的class文件路径，继而执行<code>servlet-class</code>标签中class文件的逻辑</li></ol><blockquote><p>servlet和servlet-mapping中都含有&lt;servlet-name&gt;标签，主要是通过servlet-name作为纽带，将servlet-class和url-pattern构成联系，使URL映射到servlet-class所指定的类中执行相应逻辑</p></blockquote><h2 id="Servlet接口方法"><a href="#Servlet接口方法" class="headerlink" title="Servlet接口方法"></a>Servlet接口方法</h2><p>在创建Servlet文件时，开发工具会提示开发者是否创建相应的接口方法</p><p>HTTP有8种请求方法<code>GET/POST/HEAD/OPTIONS/PUT/DELETE/TRACE/CONNECT</code>，Servlte接口中也有着相应的请求接口，这些接口对应着请求类型，<code>service()</code>方法会检查HTTP请求类型，然后在适当的时候调用<code>doGet、doPost……</code>等方法</p><ol><li>init()接口</li></ol><p>在servlet实例化后，servlet容器会调用init()方法来初始化该对象，主要是使servlet对象在处理客户请求前可以完成一些初始化工作（建立数据库的连接、获取配置信息等）init()方法在第一次创建servlet时被调用，在后续每次用户请求时将不再被调用</p><ol start="2"><li>service()接口</li></ol><p>service()方法是执行实际任务的主要方法，Servlet容器（web服务器）调用service()方法来处理来自客户端（浏览器）的请求，并将格式化的响应写回给客户端，每次服务器接收到一个Servlet请求时，服务器都会产生一个新的线程并调用服务，在service()方法被Servlet容器调用之前，确保init()方法正确完成</p><ol start="3"><li>doGet()&#x2F;doPost()……接口</li></ol><p>根据HTTP的不同请求调用不同的方法，如果HTTP得到一个来自URL的GET请求会调用doGet()方法，以此类推……</p><ol start="4"><li>destroy()接口</li></ol><p>当Servlet容器检测到一个Servlet对象应该从服务中移除时，会调用对象的destroy()方法，以便Servlet对象释放它所使用的资源，保存数据包持久化存储设备中（将内存中的数据保存到数据库中、关闭数据库连接、停止后台线程等）destroy()和init()方法一样，只会被嗲调用一次</p><ol start="5"><li>getServletConfig()接口</li></ol><p>返回Servlet容器调用init()方法时传递给Servlet对象的ServletConfig对象（ServletConfig对象包含Servlet的初始化参数）可以在web.xml中使用<code>&lt;init-param&gt;</code>标签为Servlet配置初始化参数</p><p><img data-src="/JavaEE%E6%A0%B8%E5%BF%83/image-20230711185014594.png" alt="image-20230711185014594"></p><h2 id="Servlet生命周期"><a href="#Servlet生命周期" class="headerlink" title="Servlet生命周期"></a>Servlet生命周期</h2><p>从创建到销毁的整个过程为生命周期 &#x3D;&gt; 被加载、初始化、接收请求、响应请求、以及提供服务的过程</p><p><img data-src="/JavaEE%E6%A0%B8%E5%BF%83/image-20230711185206202.png" alt="image-20230711185206202"></p><h1 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h1><p>filter被称为过滤器，是Servlet 2.3 新增的一个特性，同时它也是Servlet技术中最为实用的技术，通过filter技术能够实现对所有web资源的管理，如实现权限访问控制、过滤敏感词汇、压缩响应信息等</p><h2 id="filter配置"><a href="#filter配置" class="headerlink" title="filter配置"></a>filter配置</h2><p>类似于Servlet，由<code>&lt;filter&gt;</code>和<code>&lt;filter-mapping&gt;</code>两组标签组成，同样Servlet版本大于3.0，也可以使用注解的方式来配置filter</p><h2 id="基于web-xml配置-1"><a href="#基于web-xml配置-1" class="headerlink" title="基于web.xml配置"></a>基于web.xml配置</h2><p><img data-src="/JavaEE%E6%A0%B8%E5%BF%83/image-20230711190202260.png" alt="image-20230711190202260"></p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>&lt;filter&gt;</td><td>指定一个过滤器</td></tr><tr><td>&lt;filter-name&gt;</td><td>用于为过滤器指定一个名称，该元素的内容不能为空，</td></tr><tr><td>&lt;filter-class&gt;</td><td>用于指定过滤器的完整限定类名</td></tr><tr><td>&lt;init-param&gt;</td><td>用于为过滤器指定初始化参数</td></tr><tr><td>&lt;param-name&gt;</td><td>为&lt;init-param&gt;的子参数，用于指定参数的名称</td></tr><tr><td>&lt;param-value&gt;</td><td>为&lt;init-param&gt;的子参数，用于指定该参数的值</td></tr><tr><td>&lt;filter-mapping&gt;</td><td>用于设置一个filter所负责拦截的资源</td></tr><tr><td>&lt;filter-name&gt;</td><td>为&lt;filter-mapping&gt;子元素，用于设置filter的注册名称，该值必须是在&lt;filter&gt;元素中声明过的过滤器的名称</td></tr><tr><td>&lt;url-pattern&gt;</td><td>用于设置filter所拦截的请求路径（过滤器关联的URL样式）</td></tr><tr><td>&lt;servlet-name&gt;</td><td>用于指定过滤器所拦截的Servlet名称</td></tr></tbody></table><h2 id="基于注解方式-1"><a href="#基于注解方式-1" class="headerlink" title="基于注解方式"></a>基于注解方式</h2><p>因为Servlet的关系，在Servlet3.0后，同样不需要再web.xml中配置filter，只需要添加<code>@WebServlet</code>注解就可以修改filter的属性</p><p><img data-src="/JavaEE%E6%A0%B8%E5%BF%83/image-20230711190357321.png" alt="image-20230711190357321"></p><p><img data-src="/JavaEE%E6%A0%B8%E5%BF%83/image-20230711190414595.png" alt="image-20230711190414595"></p><h2 id="filter访问流程"><a href="#filter访问流程" class="headerlink" title="filter访问流程"></a>filter访问流程</h2><p><img data-src="/JavaEE%E6%A0%B8%E5%BF%83/image-20230711191328963.png" alt="image-20230711191328963"></p><ol><li>当用户向服务器发送请求时，服务器会接受该请求，并将请求发送到第一个过滤器中进行处理，如果存在多个过滤器按照顺序执行（filter1 -&gt; filterN）</li><li>接着调用Servlet中的service()方法，调用完成后，按照反方向顺序，从最后一个过滤器开始（filterN -&gt; filter1）</li><li>最终将处理后的结果返回给服务器，服务器在反馈给用户</li></ol><p>拦截方式也很简单，请求到达Servlet之前，检查其中的数据（也能修改其中的数据），完成后放行给Servlet</p><h2 id="filter接口方法"><a href="#filter接口方法" class="headerlink" title="filter接口方法"></a>filter接口方法</h2><ol><li>init()接口</li></ol><p>与Servlet中的init()方法类似，用于初始化过滤器，如果初始化代码要用到FilterConfig对象，则这些初始化代码只能在filter中的init()方法编写，不能在构造方法中编写</p><ol start="2"><li>doFilter()接口</li></ol><p>类似Servlet中的service()方法，客户端请求目标资源时，容器会筛选出符合<code>&lt;filter-mapping&gt;</code>标签中的<code>&lt;url-pattern&gt;</code>的filter，按照声明<code>&lt;filter-mapping&gt;</code>的顺序依次调用这些filter的doFilter()方法</p><p>doFilter()方法有多个参数，其中参数request和response为web服务器或filter链中的一个filter传递过来的请求和响应对象，参数chain代表当前filter链的对象，只有在当前filter对象中的doFilter()方法内部需要调用FilterChain对象的doFilter()方法时，才能把请求交付给filter链中的下一个filter或者目标程序处理</p><pre><code class="java">public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;
    …………
    chain.doFilter(request, response); // 传递filter链
&#125;
</code></pre><ol start="3"><li>destroy()接口</li></ol><p>filter中的destroy()方法与Servlet中的destroy()作用类似，在Web服务器卸载filter对象之前被调用，用于释放被filter对象打开的资源（关闭数据库、关闭I&#x2F;O流等）</p><h2 id="filter生命周期"><a href="#filter生命周期" class="headerlink" title="filter生命周期"></a>filter生命周期</h2><p><img data-src="/JavaEE%E6%A0%B8%E5%BF%83/image-20230711192754346.png" alt="image-20230711192754346"></p><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><blockquote><p>Java 反射机制可以无视类方法、变量去访问权限修饰符（如 protected、private 等），并且可以调用任何类的任意方法、访问并修改成员变量值</p><p>通过反射，我们可以在运行时获得程序或程序集中每一个类型的成员和成员的信息，在运行状态中，通过 Java 的反射机制，我们能够判断一个对象所属的类，了解任意一个类的所有属性和方法，能够调用任意一个对象的任意方法和属性</p></blockquote><h2 id="获取类对象"><a href="#获取类对象" class="headerlink" title="获取类对象"></a>获取类对象</h2><ol><li>forName()</li></ol><p><code>可以使用 Class 类中的方法获取类对象，就需要使用 forName() 方法，只要有类名称即可</code></p><pre><code class="java">public class Test &#123;
    public static void main(String[] args) throws ClassNotFoundException &#123;
        Class&lt;?&gt; aClass = Class.forName(&quot;java.lang.Runtime&quot;);
        System.out.println(aClass); // class java.lang.Runtime
    &#125;
&#125;
</code></pre><ol start="2"><li>直接获取</li></ol><p><code>任何数据类型都具备静态的属性，因此可以使用.class 直接获取其对应的 Class 对象</code></p><pre><code class="java">public class Test &#123;
    public static void main(String[] args)&#123;
        Class&lt;Runtime&gt; aClass = Runtime.class;
        System.out.println(aClass); // class java.lang.Runtime
    &#125;
&#125;
</code></pre><ol start="3"><li>getClose()</li></ol><p><code>可以通过 Object 类中的 getClass() 方法来获取字节码对象</code>，不过这种方法 较为烦琐，必须要明确具体的类，然后创建对象</p><pre><code class="java">public class Test &#123;
    public static void main(String[] args)&#123;
        Runtime re = Runtime.getRuntime();
        Class&lt;? extends Runtime&gt; aClass = re.getClass();
        System.out.println(aClass); // class java.lang.Runtime
    &#125;
&#125;
</code></pre><ol start="4"><li>ClassLoder.getSystemClassLoder().loadClass()</li></ol><p><code>getSystemClassLoader().loadClass()</code> 方法与 <code>forName()</code> 方法类似，只要有类名称即可</p><blockquote><p>forName()的静态方法 JVM 会装载类，并且执行 static()中的代码</p><p>getSystemClassLoader().loadClass() 不会执行 static()中 的代码</p></blockquote><pre><code class="java">public class Test &#123;
    public static void main(String[] args) throws ClassNotFoundException &#123;
        Class&lt;?&gt; aClass = ClassLoader.getSystemClassLoader().loadClass(&quot;java.lang.Runtime&quot;);
        System.out.println(aClass); // class java.lang.Runtime
    &#125;
&#125;
</code></pre><h2 id="获取类方法"><a href="#获取类方法" class="headerlink" title="获取类方法"></a>获取类方法</h2><ol><li>getDeclaredMethods()</li></ol><p><code>返回类或接口声明的所有方法，包括public、protected、private和默认方法，但不包括继承的方法</code></p><pre><code class="java">import java.lang.reflect.Method;

public class Test &#123;
    public static void main(String[] args) throws ClassNotFoundException &#123;
        Class&lt;?&gt; aClass = Class.forName(&quot;java.lang.Runtime&quot;); // 获取类对象
        System.out.println(aClass);
        Method[] method = aClass.getDeclaredMethods(); // 获取类方法
        for (Method m : method) &#123; // 遍历方法
            System.out.println(m);
        &#125;
    &#125;
&#125;
</code></pre><pre><code class="java">// 获取的方法
public void java.lang.Runtime.exit(int)
public void java.lang.Runtime.runFinalization()
public static void java.lang.Runtime.runFinalizersOnExit(boolean)
public void java.lang.Runtime.load(java.lang.String)
public void java.lang.Runtime.loadLibrary(java.lang.String)
synchronized void java.lang.Runtime.loadLibrary0(java.lang.Class,java.lang.String)
public native void java.lang.Runtime.gc()
public static java.lang.Runtime java.lang.Runtime.getRuntime()
synchronized void java.lang.Runtime.load0(java.lang.Class,java.lang.String)
public native long java.lang.Runtime.freeMemory()
public native long java.lang.Runtime.maxMemory()
public void java.lang.Runtime.addShutdownHook(java.lang.Thread)
public native int java.lang.Runtime.availableProcessors()
public java.lang.Process java.lang.Runtime.exec(java.lang.String,java.lang.String[]) throws java.io.IOException
public java.lang.Process java.lang.Runtime.exec(java.lang.String) throws java.io.IOException
public java.lang.Process java.lang.Runtime.exec(java.lang.String[]) throws java.io.IOException
public java.lang.Process java.lang.Runtime.exec(java.lang.String[],java.lang.String[],java.io.File) throws java.io.IOException
public java.lang.Process java.lang.Runtime.exec(java.lang.String[],java.lang.String[]) throws java.io.IOException
public java.lang.Process java.lang.Runtime.exec(java.lang.String,java.lang.String[],java.io.File) throws java.io.IOException
public java.io.InputStream java.lang.Runtime.getLocalizedInputStream(java.io.InputStream)
public java.io.OutputStream java.lang.Runtime.getLocalizedOutputStream(java.io.OutputStream)
public void java.lang.Runtime.halt(int)
public boolean java.lang.Runtime.removeShutdownHook(java.lang.Thread)
private static native void java.lang.Runtime.runFinalization0()
public native long java.lang.Runtime.totalMemory()
public native void java.lang.Runtime.traceInstructions(boolean)
public native void java.lang.Runtime.traceMethodCalls(boolean)
</code></pre><ol start="2"><li>getMethods()</li></ol><p><code>返回某个类的所有public方法，包括其继承类的public方法</code></p><pre><code class="java">import java.lang.reflect.Method;

public class Test &#123;
    public static void main(String[] args) throws ClassNotFoundException &#123;
        Class&lt;?&gt; aClass = Class.forName(&quot;java.lang.Runtime&quot;);
        Method[] methods = aClass.getMethods();
        for (Method m : methods) &#123;
            System.out.println(m);
        &#125;
    &#125;
&#125;
</code></pre><pre><code class="java">// 获取的方法
public void java.lang.Runtime.exit(int)
public void java.lang.Runtime.runFinalization()
public static void java.lang.Runtime.runFinalizersOnExit(boolean)
public void java.lang.Runtime.load(java.lang.String)
public void java.lang.Runtime.loadLibrary(java.lang.String)
public native void java.lang.Runtime.gc()
public static java.lang.Runtime java.lang.Runtime.getRuntime()
public native long java.lang.Runtime.freeMemory()
public native long java.lang.Runtime.maxMemory()
public void java.lang.Runtime.addShutdownHook(java.lang.Thread)
public native int java.lang.Runtime.availableProcessors()
public java.lang.Process java.lang.Runtime.exec(java.lang.String,java.lang.String[]) throws java.io.IOException
public java.lang.Process java.lang.Runtime.exec(java.lang.String) throws java.io.IOException
public java.lang.Process java.lang.Runtime.exec(java.lang.String[]) throws java.io.IOException
public java.lang.Process java.lang.Runtime.exec(java.lang.String[],java.lang.String[],java.io.File) throws java.io.IOException
public java.lang.Process java.lang.Runtime.exec(java.lang.String[],java.lang.String[]) throws java.io.IOException
public java.lang.Process java.lang.Runtime.exec(java.lang.String,java.lang.String[],java.io.File) throws java.io.IOException
public java.io.InputStream java.lang.Runtime.getLocalizedInputStream(java.io.InputStream)
public java.io.OutputStream java.lang.Runtime.getLocalizedOutputStream(java.io.OutputStream)
public void java.lang.Runtime.halt(int)
public boolean java.lang.Runtime.removeShutdownHook(java.lang.Thread)
public native long java.lang.Runtime.totalMemory()
public native void java.lang.Runtime.traceInstructions(boolean)
public native void java.lang.Runtime.traceMethodCalls(boolean)
public final void java.lang.Object.wait() throws java.lang.InterruptedException
public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException
public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException
public boolean java.lang.Object.equals(java.lang.Object)
public java.lang.String java.lang.Object.toString()
public native int java.lang.Object.hashCode()
public final native java.lang.Class java.lang.Object.getClass()
public final native void java.lang.Object.notify()
public final native void java.lang.Object.notifyAll()
</code></pre><ol start="3"><li>getDeclaredMethod()</li></ol><p><code>返回一个特定的方法，如 Runtime 类中的 exec() 方法，该方法的第一个参数为方法名称，后面的参数为方法的参数对应Class的对象</code></p><pre><code class="java">import java.lang.reflect.Method;

public class Test &#123;
    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException &#123;
        Class&lt;?&gt; aClass = Class.forName(&quot;java.lang.Runtime&quot;);
        Method exec = aClass.getDeclaredMethod(&quot;exec&quot;, String.class);
        System.out.println(exec);// public java.lang.Process java.lang.Runtime.exec(java.lang.String) throws java.io.IOException
    &#125;
&#125;
</code></pre><ol start="4"><li>getMethod()</li></ol><p>和getDeclaredMethod()一样，<code>只能返回一个特定的方法，如 Runtime 类中的 exec() 方法，该方法的第一个参数为方法名称，后面的参数为方法的参数对应Class的对象</code></p><pre><code class="java">import java.lang.reflect.Method;

public class Test &#123;
    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException &#123;
        Class&lt;?&gt; aClass = Class.forName(&quot;java.lang.Runtime&quot;);
        Method method = aClass.getMethod(&quot;exec&quot;, String.class);
        System.out.println(method); // public java.lang.Process java.lang.Runtime.exec(java.lang.String) throws java.io.IOException
    &#125;
&#125;
</code></pre><h2 id="获取类成员变量"><a href="#获取类成员变量" class="headerlink" title="获取类成员变量"></a>获取类成员变量</h2><p>创建一个父类</p><pre><code class="java">package com.study.reflect;

public class Stuss &#123;
    public int age;

    public int getAge() &#123;
        return age;
    &#125;

    public void setAge(int age) &#123;
        this.age = age;
    &#125;
&#125;
</code></pre><p>创建一个子类</p><pre><code class="java">package com.study.reflect;

public class Stu extends Stuss &#123;
    public int id;
    private String name;

    public int getId() &#123;
        return id;
    &#125;

    public void setId(int id) &#123;
        this.id = id;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;
&#125;
</code></pre><ol><li>getDeclaredFields()</li></ol><p>获得类的成员变量数组，包括 public、private和proteced，但是不包括父类的声明字段</p><pre><code class="java">import java.lang.reflect.Field;

public class Test &#123;
    public static void main(String[] args) throws ClassNotFoundException &#123;
        Class&lt;?&gt; aClass = Class.forName(&quot;com.study.reflect.Stu&quot;);
        Field[] declaredFields = aClass.getDeclaredFields();
        for (Field f:
                declaredFields) &#123;
            System.out.println(f);
        &#125;
    &#125;
&#125;
</code></pre><pre><code class="java">public int com.study.reflect.Stu.id
private java.lang.String com.study.reflect.Stu.name
</code></pre><ol start="2"><li>getFields()</li></ol><p>能获取某个类的所有public字段，包括父类中的字段</p><pre><code class="java">import java.lang.reflect.Field;

public class Test &#123;
    public static void main(String[] args) throws ClassNotFoundException &#123;
        Class&lt;?&gt; aClass = Class.forName(&quot;com.study.reflect.Stu&quot;);
        Field[] declaredFields = aClass.getFields();
        for (Field f:
                declaredFields) &#123;
            System.out.println(f);
        &#125;
    &#125;
&#125;
</code></pre><pre><code class="java">public int com.study.reflect.Stu.id
public int com.study.reflect.Stuss.age
</code></pre><ol start="3"><li>getDeclaredField()</li></ol><p>和getDeclaredFields()区别在于只能获得类的单个成员变量</p><pre><code class="java">import java.lang.reflect.Field;

public class Test &#123;
    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException &#123;
        Class&lt;?&gt; aClass = Class.forName(&quot;com.study.reflect.Stu&quot;);
        Field name = aClass.getDeclaredField(&quot;name&quot;);
        System.out.println(name);
    &#125;
&#125;
</code></pre><pre><code class="java">private java.lang.String com.study.reflect.Stu.name
</code></pre><ol start="4"><li>getField()</li></ol><p>getField方法能够获得某个类特定的public字段，其中包括父类中的字段（这里测试一下父类中的age字段）</p><pre><code class="java">import java.lang.reflect.Field;

public class Test &#123;
    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException &#123;
        Class&lt;?&gt; aClass = Class.forName(&quot;com.study.reflect.Stu&quot;);
        Field age = aClass.getField(&quot;age&quot;);
        System.out.println(age);
    &#125;
&#125;
</code></pre><pre><code class="java">public int com.study.reflect.Stuss.age
</code></pre><h2 id="获取类下的构造函数"><a href="#获取类下的构造函数" class="headerlink" title="获取类下的构造函数"></a>获取类下的构造函数</h2><ol><li><code>getConstructor</code>​</li><li><code>getConstructors</code>​</li><li><code>getDeclaredConstructor</code>​</li><li><code>getDeclaredConstructors</code>​</li></ol><h2 id="构造任意类的对象-实例化"><a href="#构造任意类的对象-实例化" class="headerlink" title="构造任意类的对象(实例化)"></a>构造任意类的对象(实例化)</h2><p>新建一个测试类</p><pre><code class="java">package com.study.reflect;

import java.io.IOException;

public class Stu extends Stuss &#123;
    public Stu()  &#123;
        System.out.println(&quot;无参数 &quot;);
    &#125;

    public Stu(String str)  &#123;
        System.out.println(&quot;有参数 &quot; + str);
    &#125;
    public int id;
    private String name;

    public int getId() &#123;
        return id;
    &#125;

    public void setId(int id) &#123;
        this.id = id;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;
    public void ex1() &#123;
        System.out.println(&quot;执行了ex1()方法&quot;);
    &#125;
    public void ex2(String str)  &#123;
        System.out.println(&quot;执行了ex1()方法, 参数是 &quot; + str);
    &#125;
&#125;
</code></pre><ol><li>无参数 className.newInstance()</li></ol><blockquote><p>构造无参数类对象</p></blockquote><pre><code class="java">import com.study.reflect.Stu;
import java.lang.reflect.InvocationTargetException;

public class Test &#123;
    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, InvocationTargetException, NoSuchMethodException &#123;
        Class&lt;?&gt; aClass = Class.forName(&quot;com.study.reflect.Stu&quot;);
        Stu stu = Stu.class.newInstance();
        System.out.println(stu);
    &#125;
&#125;
</code></pre><pre><code class="java">无参数 
com.study.reflect.Stu@1b6d3586
</code></pre><ol start="2"><li>有参数 getConstructor().newInstance()</li></ol><blockquote><p>构造存在参数类对象</p></blockquote><pre><code class="java">import com.study.reflect.Stu;
import java.lang.reflect.InvocationTargetException;

public class Test &#123;
    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, InvocationTargetException, NoSuchMethodException &#123;
        Class&lt;?&gt; aClass = Class.forName(&quot;com.study.reflect.Stu&quot;);
        Stu stu = Stu.class.getConstructor(String.class).newInstance(&quot;test&quot;);
        System.out.println(stu);
    &#125;
&#125;
</code></pre><pre><code class="java">有参数 test
com.study.reflect.Stu@1b6d3586
</code></pre><h2 id="调用任意实例类对象的方法"><a href="#调用任意实例类对象的方法" class="headerlink" title="调用任意实例类对象的方法"></a>调用任意实例类对象的方法</h2><ol><li>ObjectName.ClassFunction()</li></ol><pre><code class="java">import com.study.reflect.Stu;
import java.lang.reflect.InvocationTargetException;

public class Test &#123;
    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, InvocationTargetException, NoSuchMethodException &#123;
        Class&lt;?&gt; aClass = Class.forName(&quot;com.study.reflect.Stu&quot;);
        Stu stu = Stu.class.newInstance();
        stu.ex1();
        stu.ex2(&quot;test&quot;);
    &#125;
&#125;
</code></pre><pre><code class="java">无参数 
执行了ex1()方法
执行了ex1()方法, 参数是 test
</code></pre><ol start="2"><li>invoke(实例化后的类对象, [“参数”])</li></ol><pre><code class="java">import com.study.reflect.Stu;
import java.lang.reflect.InvocationTargetException;

public class Test1 &#123;
    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, InvocationTargetException, NoSuchMethodException &#123;
        Class&lt;?&gt; aClass = Class.forName(&quot;com.study.reflect.Stu&quot;);
        Stu stu = Stu.class.newInstance();
        
        aClass.getMethod(&quot;ex1&quot;).invoke(stu);
        aClass.getMethod(&quot;ex2&quot;, String.class).invoke(stu, &quot;通过invoke执行方法&quot;);
    &#125;
&#125;
</code></pre><pre><code class="java">无参数 
执行了ex1()方法
执行了ex1()方法, 参数是 通过invoke执行方法
</code></pre><div class="tags"><a href="/tags/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/" rel="tag"><i class="ic i-tag"></i> Java代码审计</a> <a href="/tags/Java%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E7%AF%87/" rel="tag"><i class="ic i-tag"></i> Java安全基础篇</a></div></div><footer><div class="meta"></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="余星酒 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="余星酒 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="余星酒 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>余星酒 <i class="ic i-at"><em>@</em></i>余星酒</li><li class="link"><strong>本文链接：</strong> <a href="http://example.com/APT/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/%E5%AE%A1%E8%AE%A1%E5%9F%BA%E7%A1%80/JaveEE%E6%A0%B8%E5%BF%83/" title="10. JaveEE核心">http://example.com/APT/代码审计/Java代码审计/审计基础/JaveEE核心/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/APT/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/%E5%AE%A1%E8%AE%A1%E5%9F%BA%E7%A1%80/%E5%AE%A1%E8%AE%A1%E6%80%9D%E8%B7%AF/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclhnx9glj20zk0m8npd.jpg" title="审计思路"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 代码审计</span><h3>审计思路</h3></a></div><div class="item right"><a href="/APT/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/%E5%AE%A1%E8%AE%A1%E5%9F%BA%E7%A1%80/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gicljitigmj20zk0m87fp.jpg" title="1. java类加载机制"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> Java安全基础</span><h3>1. java类加载机制</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaEE%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.</span> <span class="toc-text">JavaEE分层模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaEE%E7%9A%84%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF"><span class="toc-number">1.1.</span> <span class="toc-text">JavaEE的核心技术</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaEE%E5%88%86%E5%B1%82"><span class="toc-number">1.2.</span> <span class="toc-text">JavaEE分层</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MVC%E6%A8%A1%E5%BC%8F%E4%B8%8EMVC%E6%A1%86%E6%9E%B6"><span class="toc-number">2.</span> <span class="toc-text">MVC模式与MVC框架</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-MVC%E6%A1%86%E6%9E%B6"><span class="toc-number">2.1.</span> <span class="toc-text">Java MVC框架</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Servlet"><span class="toc-number">3.</span> <span class="toc-text">Servlet</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Servlet%E9%85%8D%E7%BD%AE"><span class="toc-number">3.1.</span> <span class="toc-text">Servlet配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8Eweb-xml%E9%85%8D%E7%BD%AE"><span class="toc-number">3.2.</span> <span class="toc-text">基于web.xml配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F"><span class="toc-number">3.3.</span> <span class="toc-text">基于注解方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Servlet%E8%AE%BF%E9%97%AE%E6%B5%81%E7%A8%8B"><span class="toc-number">3.4.</span> <span class="toc-text">Servlet访问流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Servlet%E6%8E%A5%E5%8F%A3%E6%96%B9%E6%B3%95"><span class="toc-number">3.5.</span> <span class="toc-text">Servlet接口方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Servlet%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">3.6.</span> <span class="toc-text">Servlet生命周期</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#filter"><span class="toc-number">4.</span> <span class="toc-text">filter</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#filter%E9%85%8D%E7%BD%AE"><span class="toc-number">4.1.</span> <span class="toc-text">filter配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8Eweb-xml%E9%85%8D%E7%BD%AE-1"><span class="toc-number">4.2.</span> <span class="toc-text">基于web.xml配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F-1"><span class="toc-number">4.3.</span> <span class="toc-text">基于注解方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#filter%E8%AE%BF%E9%97%AE%E6%B5%81%E7%A8%8B"><span class="toc-number">4.4.</span> <span class="toc-text">filter访问流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#filter%E6%8E%A5%E5%8F%A3%E6%96%B9%E6%B3%95"><span class="toc-number">4.5.</span> <span class="toc-text">filter接口方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#filter%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">4.6.</span> <span class="toc-text">filter生命周期</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">5.</span> <span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%B1%BB%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.1.</span> <span class="toc-text">获取类对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-number">5.2.</span> <span class="toc-text">获取类方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%B1%BB%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">5.3.</span> <span class="toc-text">获取类成员变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%B1%BB%E4%B8%8B%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">5.4.</span> <span class="toc-text">获取类下的构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E4%BB%BB%E6%84%8F%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1-%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-number">5.5.</span> <span class="toc-text">构造任意类的对象(实例化)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E4%BB%BB%E6%84%8F%E5%AE%9E%E4%BE%8B%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">5.6.</span> <span class="toc-text">调用任意实例类对象的方法</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/APT/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/%E5%AE%A1%E8%AE%A1%E5%9F%BA%E7%A1%80/%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8/" rel="bookmark" title="idea基础使用">idea基础使用</a></li><li><a href="/APT/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/%E5%AE%A1%E8%AE%A1%E5%9F%BA%E7%A1%80/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/" rel="bookmark" title="动态代理">动态代理</a></li><li><a href="/APT/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/%E5%AE%A1%E8%AE%A1%E5%9F%BA%E7%A1%80/%E7%B1%BB%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/" rel="bookmark" title="类动态加载">类动态加载</a></li><li><a href="/APT/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/%E5%AE%A1%E8%AE%A1%E5%9F%BA%E7%A1%80/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" rel="bookmark" title="Java序列化和反序列化">Java序列化和反序列化</a></li><li><a href="/APT/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/%E5%AE%A1%E8%AE%A1%E5%9F%BA%E7%A1%80/Java%E5%8F%8D%E5%B0%84/" rel="bookmark" title="Java反射">Java反射</a></li><li class="active"><a href="/APT/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/%E5%AE%A1%E8%AE%A1%E5%9F%BA%E7%A1%80/JaveEE%E6%A0%B8%E5%BF%83/" rel="bookmark" title="10. JaveEE核心">10. JaveEE核心</a></li><li><a href="/APT/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/%E5%AE%A1%E8%AE%A1%E5%9F%BA%E7%A1%80/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" rel="bookmark" title="1. java类加载机制">1. java类加载机制</a></li><li><a href="/APT/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/%E5%AE%A1%E8%AE%A1%E5%9F%BA%E7%A1%80/sun.misc.Unsafe/" rel="bookmark" title="3. sun.misc.Unsafe">3. sun.misc.Unsafe</a></li><li><a href="/APT/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/%E5%AE%A1%E8%AE%A1%E5%9F%BA%E7%A1%80/Java%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/" rel="bookmark" title="4. java文件系统安全">4. java文件系统安全</a></li><li><a href="/APT/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/%E5%AE%A1%E8%AE%A1%E5%9F%BA%E7%A1%80/JDBC/" rel="bookmark" title="6. JDBC">6. JDBC</a></li><li><a href="/APT/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/%E5%AE%A1%E8%AE%A1%E5%9F%BA%E7%A1%80/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/" rel="bookmark" title="Tomcat内存马">Tomcat内存马</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="余星酒" data-src="/images/avatar.jpg"><p class="name" itemprop="name">余星酒</p><div class="description" itemprop="description">欢迎参观我的笔记空间 ~ 这里主要会记录一些安全相关的学习笔记 🌸</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">253</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">43</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">36</span> <span class="name">标签</span></a></div></nav><div class="social"></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/APT/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/%E5%AE%A1%E8%AE%A1%E5%9F%BA%E7%A1%80/%E5%AE%A1%E8%AE%A1%E6%80%9D%E8%B7%AF/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/APT/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/%E5%AE%A1%E8%AE%A1%E5%9F%BA%E7%A1%80/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/" title="分类于 代码审计">代码审计</a> <i class="ic i-angle-right"></i> <a href="/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/Java%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/" title="分类于 Java安全基础">Java安全基础</a></div><span><a href="/APT/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/%E5%AE%A1%E8%AE%A1%E5%9F%BA%E7%A1%80/JDBC/" title="6. JDBC">6. JDBC</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Network/" title="分类于 网络">网络</a> <i class="ic i-angle-right"></i> <a href="/categories/Network/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/" title="分类于 网络基础">网络基础</a></div><span><a href="/Network/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/HCIA/STP/" title="STP">STP</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Program/" title="分类于 编程">编程</a> <i class="ic i-angle-right"></i> <a href="/categories/Program/Golang/" title="分类于 Golang">Golang</a> <i class="ic i-angle-right"></i> <a href="/categories/Program/Golang/%E8%BF%9B%E9%98%B6/" title="分类于 进阶">进阶</a></div><span><a href="/Program/golang/%E8%BF%9B%E9%98%B6/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/" title="文件操作">文件操作</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/System/" title="分类于 操作系统">操作系统</a> <i class="ic i-angle-right"></i> <a href="/categories/System/centos/" title="分类于 centos">centos</a></div><span><a href="/System/centos/docker%E4%BD%BF%E7%94%A8/" title="docker使用">docker使用</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/APT/" title="分类于 渗透测试">渗透测试</a> <i class="ic i-angle-right"></i> <a href="/categories/APT/%E9%9D%B6%E5%9C%BA/" title="分类于 靶场">靶场</a></div><span><a href="/APT/%E9%9D%B6%E5%9C%BAwp/%E9%9D%B6%E5%9C%BA/vulnhub/Empire-Lupin-One-1/" title="Empire Lupin One-1">Empire Lupin One-1</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/Other/011-%E5%8F%8D%E5%BC%B9shell/019-Powershell%E5%8F%8D%E5%BC%B9shell/" title="未命名">未命名</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Network/" title="分类于 网络">网络</a> <i class="ic i-angle-right"></i> <a href="/categories/Network/%E6%B7%B1%E4%BF%A1%E6%9C%8D%E8%AE%BE%E5%A4%87/" title="分类于 深信服设备">深信服设备</a> <i class="ic i-angle-right"></i> <a href="/categories/Network/%E6%B7%B1%E4%BF%A1%E6%9C%8D%E8%AE%BE%E5%A4%87/AC/" title="分类于 AC">AC</a></div><span><a href="/Network/%E6%B7%B1%E4%BF%A1%E6%9C%8D%E8%AE%BE%E5%A4%87/%E6%B7%B1%E4%BF%A1%E6%9C%8D/AC/%E5%AE%A1%E8%AE%A1/" title="审计">审计</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Network/" title="分类于 网络">网络</a> <i class="ic i-angle-right"></i> <a href="/categories/Network/%E6%B7%B1%E4%BF%A1%E6%9C%8D%E8%AE%BE%E5%A4%87/" title="分类于 深信服设备">深信服设备</a> <i class="ic i-angle-right"></i> <a href="/categories/Network/%E6%B7%B1%E4%BF%A1%E6%9C%8D%E8%AE%BE%E5%A4%87/%E5%AE%9E%E9%AA%8C/" title="分类于 实验">实验</a></div><span><a href="/Network/%E6%B7%B1%E4%BF%A1%E6%9C%8D%E8%AE%BE%E5%A4%87/%E9%98%B6%E6%AE%B5%E6%B5%8B%E8%AF%95/AF/" title="AF">AF</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/APT/" title="分类于 渗透测试">渗透测试</a> <i class="ic i-angle-right"></i> <a href="/categories/APT/%E9%9D%B6%E5%9C%BA/" title="分类于 靶场">靶场</a></div><span><a href="/APT/%E9%9D%B6%E5%9C%BAwp/%E9%9D%B6%E5%9C%BA/vulnhub/Chili-1/" title="Chili-1">Chili-1</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/PDCERF/" title="分类于 应急响应">应急响应</a> <i class="ic i-angle-right"></i> <a href="/categories/PDCERF/Windows%E5%BA%94%E6%80%A5%E7%AC%94%E8%AE%B0/" title="分类于 Windows应急笔记">Windows应急笔记</a></div><span><a href="/PDCERF/Windows%E5%AE%9E%E6%88%98%E7%AF%87/FTP%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/" title="FTP暴力破解">FTP暴力破解</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">余星酒 @ 余星酒</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"APT/代码审计/Java代码审计/审计基础/JaveEE核心/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->