<!-- build time:Thu Jan 18 2024 13:01:15 GMT+0800 (China Standard Time) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="余星酒" href="http://example.com/rss.xml"><link rel="alternate" type="application/atom+xml" title="余星酒" href="http://example.com/atom.xml"><link rel="alternate" type="application/json" title="余星酒" href="http://example.com/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="Java代码审计,Java安全基础篇"><link rel="canonical" href="http://example.com/APT/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/%E5%AE%A1%E8%AE%A1%E5%9F%BA%E7%A1%80/Java%E5%8F%8D%E5%B0%84/"><title>Java反射 - Java安全基础 - 代码审计 | 余星酒 = 余星酒 = 痴看年少风雨疾，一转本生蹉跎游</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">Java反射</h1><div class="meta"><span class="item" title="创建时间：2023-02-12 18:14:29"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2023-02-12T18:14:29+08:00">2023-02-12</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">余星酒</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gicit4jrvuj20zk0m8785.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipew28b65j20zk0m8hdt.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giclwuom7cj20zk0m8dvn.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giciuv0socj20zk0m8qes.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipesx5fdwj20zk0m81kx.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipew8gmvyj20zk0m87wh.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/" itemprop="item" rel="index" title="分类于 代码审计"><span itemprop="name">代码审计</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/Java%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/" itemprop="item" rel="index" title="分类于 Java安全基础"><span itemprop="name">Java安全基础</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/APT/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/%E5%AE%A1%E8%AE%A1%E5%9F%BA%E7%A1%80/Java%E5%8F%8D%E5%B0%84/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="余星酒"><meta itemprop="description" content="痴看年少风雨疾，一转本生蹉跎游, 欢迎参观我的笔记空间 ~ 这里主要会记录一些安全相关的学习笔记 🌸"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="余星酒"></span><div class="body md" itemprop="articleBody"><h1 id="Java反射"><a href="#Java反射" class="headerlink" title="Java反射"></a>Java反射</h1><h1 id="反射介绍"><a href="#反射介绍" class="headerlink" title="反射介绍"></a>反射介绍</h1><p>**Java 反射(**​<code>Reflection</code>​)是 Java 非常重要的动态特性，通过使用反射我们不仅可以获取到任何类的成员方法(<code>Methods</code>​)、成员变量(<code>Fields</code>​)、构造方法(<code>Constructors</code>​)等信息，还可以动态创建 Java 类实例、调用任意的类方法、修改任意的类成员变量值等。Java 反射机制是 Java 语言的动态性的重要体现，也是 Java 的各种框架底层实现的灵魂</p><p><img data-src="/java%E5%8F%8D%E5%B0%84/20230914112253.png">​</p><p>在Java中看到的绝大部分成员，其实都可以称之为对象（ 除了普通数据类型和静态成员 ）​<code>public class Student&#123;&#125;</code>​</p><p>类也是对象，类是<code>java.lang.Class</code>​类的实例对象，比如Student的类，这个类本身就是一个对象 Class类的实例对象</p><p><code>new Student().getClass().getClass()</code>​</p><p>也就是说<code>new Student().getClass()</code>​获取的是 <code>class cmder.CmdSerialize</code>​</p><p>而<code>new Student().getClass().getClass()</code>​就是获取的是 <code>class java.lang.Class</code>​</p><h1 id="反射常用方法"><a href="#反射常用方法" class="headerlink" title="反射常用方法"></a>反射常用方法</h1><p>这里准备一个测试类</p><pre><code class="java">package servletTest;

public class testClass &#123;

    public String name;
    private String pass=&quot;nil&quot;;

    public void setPass(String pass) &#123;
        this.pass = pass;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public String getPass() &#123;
        return pass;
    &#125;

    public String getName() &#123;
        return name;
    &#125;
    public void pr(String name, String pass) &#123;
        System.out.println(&quot;name : &quot;+ name + &quot;\npass : &quot; + pass + &quot;\n&quot;);
    &#125;

    public void pr(int index, String pass) &#123;
        System.out.println(&quot;index : &quot;+ index + &quot;\npass : &quot; + pass + &quot;\n&quot;);
    &#125;
&#125;
</code></pre><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><blockquote><p>Java 反射机制可以无视类方法、变量去访问权限修饰符（如 protected、private 等），并且可以调用任何类的任意方法、访问并修改成员变量值</p><p>通过反射，我们可以在运行时获得程序或程序集中每一个类型的成员和成员的信息，在运行状态中，通过 Java 的反射机制，我们能够判断一个对象所属的类，了解任意一个类的所有属性和方法，能够调用任意一个对象的任意方法和属性</p></blockquote><h2 id="获取类对象"><a href="#获取类对象" class="headerlink" title="获取类对象"></a>获取类对象</h2><ol><li>forName()</li></ol><p><code>可以使用 Class 类中的方法获取类对象，就需要使用 forName() 方法，只要有类名称即可</code></p><pre><code class="java">public class Test &#123;
    public static void main(String[] args) throws ClassNotFoundException &#123;
        Class&lt;?&gt; aClass = Class.forName(&quot;java.lang.Runtime&quot;);
        System.out.println(aClass); // class java.lang.Runtime
    &#125;
&#125;
</code></pre><ol start="2"><li>直接获取</li></ol><p><code>任何数据类型都具备静态的属性，因此可以使用.class 直接获取其对应的 Class 对象</code></p><pre><code class="java">public class Test &#123;
    public static void main(String[] args)&#123;
        Class&lt;Runtime&gt; aClass = Runtime.class;
        System.out.println(aClass); // class java.lang.Runtime
    &#125;
&#125;
</code></pre><ol start="3"><li>getClose()</li></ol><p><code>可以通过 Object 类中的 getClass() 方法来获取字节码对象</code>，不过这种方法 较为烦琐，必须要明确具体的类，然后创建对象</p><pre><code class="java">public class Test &#123;
    public static void main(String[] args)&#123;
        Runtime re = Runtime.getRuntime();
        Class&lt;? extends Runtime&gt; aClass = re.getClass();
        System.out.println(aClass); // class java.lang.Runtime
    &#125;
&#125;
</code></pre><ol start="4"><li>ClassLoder.getSystemClassLoder().loadClass()</li></ol><p><code>getSystemClassLoader().loadClass()</code> 方法与 <code>forName()</code> 方法类似，只要有类名称即可</p><blockquote><p>forName()的静态方法 JVM 会装载类，并且执行 static()中的代码</p><p>getSystemClassLoader().loadClass() 不会执行 static()中 的代码</p></blockquote><pre><code class="java">public class Test &#123;
    public static void main(String[] args) throws ClassNotFoundException &#123;
        Class&lt;?&gt; aClass = ClassLoader.getSystemClassLoader().loadClass(&quot;java.lang.Runtime&quot;);
        System.out.println(aClass); // class java.lang.Runtime
    &#125;
&#125;
</code></pre><h2 id="获取类方法"><a href="#获取类方法" class="headerlink" title="获取类方法"></a>获取类方法</h2><ol><li>getDeclaredMethods()</li></ol><p><code>返回类或接口声明的所有方法，包括public、protected、private和默认方法，但不包括继承的方法</code></p><pre><code class="java">import java.lang.reflect.Method;

public class Test &#123;
    public static void main(String[] args) throws ClassNotFoundException &#123;
        Class&lt;?&gt; aClass = Class.forName(&quot;java.lang.Runtime&quot;); // 获取类对象
        System.out.println(aClass);
        Method[] method = aClass.getDeclaredMethods(); // 获取类方法
        for (Method m : method) &#123; // 遍历方法
            System.out.println(m);
        &#125;
    &#125;
&#125;
</code></pre><pre><code class="java">// 获取的方法
public void java.lang.Runtime.exit(int)
public void java.lang.Runtime.runFinalization()
public static void java.lang.Runtime.runFinalizersOnExit(boolean)
public void java.lang.Runtime.load(java.lang.String)
public void java.lang.Runtime.loadLibrary(java.lang.String)
synchronized void java.lang.Runtime.loadLibrary0(java.lang.Class,java.lang.String)
public native void java.lang.Runtime.gc()
public static java.lang.Runtime java.lang.Runtime.getRuntime()
synchronized void java.lang.Runtime.load0(java.lang.Class,java.lang.String)
public native long java.lang.Runtime.freeMemory()
public native long java.lang.Runtime.maxMemory()
public void java.lang.Runtime.addShutdownHook(java.lang.Thread)
public native int java.lang.Runtime.availableProcessors()
public java.lang.Process java.lang.Runtime.exec(java.lang.String,java.lang.String[]) throws java.io.IOException
public java.lang.Process java.lang.Runtime.exec(java.lang.String) throws java.io.IOException
public java.lang.Process java.lang.Runtime.exec(java.lang.String[]) throws java.io.IOException
public java.lang.Process java.lang.Runtime.exec(java.lang.String[],java.lang.String[],java.io.File) throws java.io.IOException
public java.lang.Process java.lang.Runtime.exec(java.lang.String[],java.lang.String[]) throws java.io.IOException
public java.lang.Process java.lang.Runtime.exec(java.lang.String,java.lang.String[],java.io.File) throws java.io.IOException
public java.io.InputStream java.lang.Runtime.getLocalizedInputStream(java.io.InputStream)
public java.io.OutputStream java.lang.Runtime.getLocalizedOutputStream(java.io.OutputStream)
public void java.lang.Runtime.halt(int)
public boolean java.lang.Runtime.removeShutdownHook(java.lang.Thread)
private static native void java.lang.Runtime.runFinalization0()
public native long java.lang.Runtime.totalMemory()
public native void java.lang.Runtime.traceInstructions(boolean)
public native void java.lang.Runtime.traceMethodCalls(boolean)
</code></pre><ol start="2"><li>getMethods()</li></ol><p><code>返回某个类的所有public方法，包括其继承类的public方法</code></p><pre><code class="java">import java.lang.reflect.Method;

public class Test &#123;
    public static void main(String[] args) throws ClassNotFoundException &#123;
        Class&lt;?&gt; aClass = Class.forName(&quot;java.lang.Runtime&quot;);
        Method[] methods = aClass.getMethods();
        for (Method m : methods) &#123;
            System.out.println(m);
        &#125;
    &#125;
&#125;
</code></pre><pre><code class="java">// 获取的方法
public void java.lang.Runtime.exit(int)
public void java.lang.Runtime.runFinalization()
public static void java.lang.Runtime.runFinalizersOnExit(boolean)
public void java.lang.Runtime.load(java.lang.String)
public void java.lang.Runtime.loadLibrary(java.lang.String)
public native void java.lang.Runtime.gc()
public static java.lang.Runtime java.lang.Runtime.getRuntime()
public native long java.lang.Runtime.freeMemory()
public native long java.lang.Runtime.maxMemory()
public void java.lang.Runtime.addShutdownHook(java.lang.Thread)
public native int java.lang.Runtime.availableProcessors()
public java.lang.Process java.lang.Runtime.exec(java.lang.String,java.lang.String[]) throws java.io.IOException
public java.lang.Process java.lang.Runtime.exec(java.lang.String) throws java.io.IOException
public java.lang.Process java.lang.Runtime.exec(java.lang.String[]) throws java.io.IOException
public java.lang.Process java.lang.Runtime.exec(java.lang.String[],java.lang.String[],java.io.File) throws java.io.IOException
public java.lang.Process java.lang.Runtime.exec(java.lang.String[],java.lang.String[]) throws java.io.IOException
public java.lang.Process java.lang.Runtime.exec(java.lang.String,java.lang.String[],java.io.File) throws java.io.IOException
public java.io.InputStream java.lang.Runtime.getLocalizedInputStream(java.io.InputStream)
public java.io.OutputStream java.lang.Runtime.getLocalizedOutputStream(java.io.OutputStream)
public void java.lang.Runtime.halt(int)
public boolean java.lang.Runtime.removeShutdownHook(java.lang.Thread)
public native long java.lang.Runtime.totalMemory()
public native void java.lang.Runtime.traceInstructions(boolean)
public native void java.lang.Runtime.traceMethodCalls(boolean)
public final void java.lang.Object.wait() throws java.lang.InterruptedException
public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException
public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException
public boolean java.lang.Object.equals(java.lang.Object)
public java.lang.String java.lang.Object.toString()
public native int java.lang.Object.hashCode()
public final native java.lang.Class java.lang.Object.getClass()
public final native void java.lang.Object.notify()
public final native void java.lang.Object.notifyAll()
</code></pre><ol start="3"><li>getDeclaredMethod()</li></ol><p><code>返回一个特定的方法，如 Runtime 类中的 exec() 方法，该方法的第一个参数为方法名称，后面的参数为方法的参数对应Class的对象</code></p><pre><code class="java">import java.lang.reflect.Method;

public class Test &#123;
    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException &#123;
        Class&lt;?&gt; aClass = Class.forName(&quot;java.lang.Runtime&quot;);
        Method exec = aClass.getDeclaredMethod(&quot;exec&quot;, String.class);
        System.out.println(exec);// public java.lang.Process java.lang.Runtime.exec(java.lang.String) throws java.io.IOException
    &#125;
&#125;
</code></pre><ol start="4"><li>getMethod()</li></ol><p>和getDeclaredMethod()一样，<code>只能返回一个特定的方法，如 Runtime 类中的 exec() 方法，该方法的第一个参数为方法名称，后面的参数为方法的参数对应Class的对象</code></p><pre><code class="java">import java.lang.reflect.Method;

public class Test &#123;
    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException &#123;
        Class&lt;?&gt; aClass = Class.forName(&quot;java.lang.Runtime&quot;);
        Method method = aClass.getMethod(&quot;exec&quot;, String.class);
        System.out.println(method); // public java.lang.Process java.lang.Runtime.exec(java.lang.String) throws java.io.IOException
    &#125;
&#125;
</code></pre><h2 id="获取类成员变量"><a href="#获取类成员变量" class="headerlink" title="获取类成员变量"></a>获取类成员变量</h2><p>创建一个父类</p><pre><code class="java">package com.study.reflect;

public class Stuss &#123;
    public int age;

    public int getAge() &#123;
        return age;
    &#125;

    public void setAge(int age) &#123;
        this.age = age;
    &#125;
&#125;
</code></pre><p>创建一个子类</p><pre><code class="java">package com.study.reflect;

public class Stu extends Stuss &#123;
    public int id;
    private String name;

    public int getId() &#123;
        return id;
    &#125;

    public void setId(int id) &#123;
        this.id = id;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;
&#125;
</code></pre><ol><li>getDeclaredFields()</li></ol><p>获得类的成员变量数组，包括 public、private和proteced，但是不包括父类的声明字段</p><pre><code class="java">import java.lang.reflect.Field;

public class Test &#123;
    public static void main(String[] args) throws ClassNotFoundException &#123;
        Class&lt;?&gt; aClass = Class.forName(&quot;com.study.reflect.Stu&quot;);
        Field[] declaredFields = aClass.getDeclaredFields();
        for (Field f:
                declaredFields) &#123;
            System.out.println(f);
        &#125;
    &#125;
&#125;
</code></pre><pre><code class="java">public int com.study.reflect.Stu.id
private java.lang.String com.study.reflect.Stu.name
</code></pre><ol start="2"><li>getFields()</li></ol><p>能获取某个类的所有public字段，包括父类中的字段</p><pre><code class="java">import java.lang.reflect.Field;

public class Test &#123;
    public static void main(String[] args) throws ClassNotFoundException &#123;
        Class&lt;?&gt; aClass = Class.forName(&quot;com.study.reflect.Stu&quot;);
        Field[] declaredFields = aClass.getFields();
        for (Field f:
                declaredFields) &#123;
            System.out.println(f);
        &#125;
    &#125;
&#125;
</code></pre><pre><code class="java">public int com.study.reflect.Stu.id
public int com.study.reflect.Stuss.age
</code></pre><ol start="3"><li>getDeclaredField()</li></ol><p>和getDeclaredFields()区别在于只能获得类的单个成员变量</p><pre><code class="java">import java.lang.reflect.Field;

public class Test &#123;
    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException &#123;
        Class&lt;?&gt; aClass = Class.forName(&quot;com.study.reflect.Stu&quot;);
        Field name = aClass.getDeclaredField(&quot;name&quot;);
        System.out.println(name);
    &#125;
&#125;
</code></pre><pre><code class="java">private java.lang.String com.study.reflect.Stu.name
</code></pre><ol start="4"><li>getField()</li></ol><p>getField方法能够获得某个类特定的public字段，其中包括父类中的字段（这里测试一下父类中的age字段）</p><pre><code class="java">import java.lang.reflect.Field;

public class Test &#123;
    public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException &#123;
        Class&lt;?&gt; aClass = Class.forName(&quot;com.study.reflect.Stu&quot;);
        Field age = aClass.getField(&quot;age&quot;);
        System.out.println(age);
    &#125;
&#125;
</code></pre><pre><code class="java">public int com.study.reflect.Stuss.age
</code></pre><h2 id="获取类下的构造函数"><a href="#获取类下的构造函数" class="headerlink" title="获取类下的构造函数"></a>获取类下的构造函数</h2><ol><li><code>getConstructor</code>​</li><li><code>getConstructors</code>​</li><li><code>getDeclaredConstructor</code>​</li><li><code>getDeclaredConstructors</code>​</li></ol><h2 id="构造任意类的对象-实例化"><a href="#构造任意类的对象-实例化" class="headerlink" title="构造任意类的对象(实例化)"></a>构造任意类的对象(实例化)</h2><p>新建一个测试类</p><pre><code class="java">package com.study.reflect;

import java.io.IOException;

public class Stu extends Stuss &#123;
    public Stu()  &#123;
        System.out.println(&quot;无参数 &quot;);
    &#125;

    public Stu(String str)  &#123;
        System.out.println(&quot;有参数 &quot; + str);
    &#125;
    public int id;
    private String name;

    public int getId() &#123;
        return id;
    &#125;

    public void setId(int id) &#123;
        this.id = id;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;
    public void ex1() &#123;
        System.out.println(&quot;执行了ex1()方法&quot;);
    &#125;
    public void ex2(String str)  &#123;
        System.out.println(&quot;执行了ex1()方法, 参数是 &quot; + str);
    &#125;
&#125;
</code></pre><ol><li>无参数 className.newInstance()</li></ol><blockquote><p>构造无参数类对象</p></blockquote><pre><code class="java">import com.study.reflect.Stu;
import java.lang.reflect.InvocationTargetException;

public class Test &#123;
    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, InvocationTargetException, NoSuchMethodException &#123;
        Class&lt;?&gt; aClass = Class.forName(&quot;com.study.reflect.Stu&quot;);
        Stu stu = Stu.class.newInstance();
        System.out.println(stu);
    &#125;
&#125;
</code></pre><pre><code class="java">无参数 
com.study.reflect.Stu@1b6d3586
</code></pre><ol start="2"><li>有参数 getConstructor().newInstance()</li></ol><blockquote><p>构造存在参数类对象</p></blockquote><pre><code class="java">import com.study.reflect.Stu;
import java.lang.reflect.InvocationTargetException;

public class Test &#123;
    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, InvocationTargetException, NoSuchMethodException &#123;
        Class&lt;?&gt; aClass = Class.forName(&quot;com.study.reflect.Stu&quot;);
        Stu stu = Stu.class.getConstructor(String.class).newInstance(&quot;test&quot;);
        System.out.println(stu);
    &#125;
&#125;
</code></pre><pre><code class="java">有参数 test
com.study.reflect.Stu@1b6d3586
</code></pre><h2 id="调用任意实例类对象的方法"><a href="#调用任意实例类对象的方法" class="headerlink" title="调用任意实例类对象的方法"></a>调用任意实例类对象的方法</h2><ol><li>ObjectName.ClassFunction()</li></ol><pre><code class="java">import com.study.reflect.Stu;
import java.lang.reflect.InvocationTargetException;

public class Test &#123;
    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, InvocationTargetException, NoSuchMethodException &#123;
        Class&lt;?&gt; aClass = Class.forName(&quot;com.study.reflect.Stu&quot;);
        Stu stu = Stu.class.newInstance();
        stu.ex1();
        stu.ex2(&quot;test&quot;);
    &#125;
&#125;
</code></pre><pre><code class="java">无参数 
执行了ex1()方法
执行了ex1()方法, 参数是 test
</code></pre><ol start="2"><li>invoke(实例化后的类对象, [“参数”])</li></ol><pre><code class="java">import com.study.reflect.Stu;
import java.lang.reflect.InvocationTargetException;

public class Test1 &#123;
    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, InvocationTargetException, NoSuchMethodException &#123;
        Class&lt;?&gt; aClass = Class.forName(&quot;com.study.reflect.Stu&quot;);
        Stu stu = Stu.class.newInstance();
        
        aClass.getMethod(&quot;ex1&quot;).invoke(stu);
        aClass.getMethod(&quot;ex2&quot;, String.class).invoke(stu, &quot;通过invoke执行方法&quot;);
    &#125;
&#125;
</code></pre><pre><code class="java">无参数 
执行了ex1()方法
执行了ex1()方法, 参数是 通过invoke执行方法
</code></pre><h1 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h1><h2 id="普通调用方式"><a href="#普通调用方式" class="headerlink" title="普通调用方式"></a>普通调用方式</h2><p><strong>方法一</strong></p><pre><code class="java">    Runtime.getRuntime().exec(&quot;calc&quot;);
</code></pre><p><img data-src="/java%E5%8F%8D%E5%B0%84/20230914210121.png">​</p><p>直接调用是无法访问的，它提供了一个方法<code>getRuntime()</code>​会返回该类的实例</p><pre><code class="java">package runtimeExec;

import java.io.IOException;

public class main &#123;
    public static void main(String[] args) throws IOException &#123;
        System.out.println(Runtime.getRuntime().exec(&quot;calc&quot;));
    &#125;
&#125;
</code></pre><p><strong>方法二</strong></p><pre><code class="java">package runtimeExec;

import java.io.IOException;
import java.lang.reflect.InvocationTargetException;

public class main &#123;
    public static void main(String[] args) throws IOException&#123;
        ProcessBuilder cmd = new ProcessBuilder(&quot;calc&quot;);
        cmd.start();
    &#125;
&#125;
</code></pre><h2 id="通过反射调用"><a href="#通过反射调用" class="headerlink" title="通过反射调用"></a>通过反射调用</h2><p><strong>方法一 : 先返回的Runtime对象在通过invoke传入返回的Runtime对象和参数执行exec函数</strong></p><pre><code class="java">package runtimeExec;

import java.io.IOException;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;

public class main &#123;
    public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException, ClassNotFoundException &#123;
        // 通过获取类对象的getRuntime方法(由于这个方法没有参数，所以直接写入即可)这个函数会返回一个Runtime实例,通过调用invoke执行(因为getRuntime函数不需要接收任何参数)，此时就会返回一个Runtime对象
        Object o = Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;).invoke(null);  // java.lang.Runtime@75ba3523
        Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;exec&quot;, String.class).invoke(o, &quot;calc&quot;);
    &#125;
&#125;
</code></pre><p><strong>方法二 : 通过类构造函数获取exec函数，通过invoke传入构造函数.newInstance()实例对象和参数执行</strong></p><pre><code class="java">package runtimeExec;

import java.io.IOException;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;

public class main &#123;
    public static void main(String[] args) throws IOException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, ClassNotFoundException &#123;

        Class aClass = Class.forName(&quot;java.lang.Runtime&quot;); // 获取类对象
        Constructor cmd = aClass.getDeclaredConstructor(); // 获取类结构体

        cmd.setAccessible(true); // 关闭java安全检测

        aClass.getMethod(&quot;exec&quot;, String.class).invoke(cmd.newInstance(), &quot;calc&quot;); // 获取exec方法，并传入参数类型，最后执行函数
    &#125;
&#125;
</code></pre><p><strong>方法三 : 利用ProcessBuilder通过getMethod反射获取start方法，然后传入start的类对象，也就是需要一个ProcessBuilder对象，通过newInstance方式获取</strong></p><pre><code class="java">package runtimeExec;

import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.util.Arrays;
import java.util.List;

public class main &#123;
    public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, ClassNotFoundException &#123;
        Class.forName(&quot;java.lang.ProcessBuilder&quot;).getMethod(&quot;start&quot;).invoke(Class.forName(&quot;java.lang.ProcessBuilder&quot;).getConstructor(List.class).newInstance(Arrays.asList(&quot;calc&quot;)));

    &#125;
&#125;
</code></pre><div class="tags"><a href="/tags/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/" rel="tag"><i class="ic i-tag"></i> Java代码审计</a> <a href="/tags/Java%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%E7%AF%87/" rel="tag"><i class="ic i-tag"></i> Java安全基础篇</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-12-26 19:18:03" itemprop="dateModified" datetime="2023-12-26T19:18:03+08:00">2023-12-26</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="余星酒 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="余星酒 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="余星酒 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>余星酒 <i class="ic i-at"><em>@</em></i>余星酒</li><li class="link"><strong>本文链接：</strong> <a href="http://example.com/APT/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/%E5%AE%A1%E8%AE%A1%E5%9F%BA%E7%A1%80/Java%E5%8F%8D%E5%B0%84/" title="Java反射">http://example.com/APT/代码审计/Java代码审计/审计基础/Java反射/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/APT/web%E6%B8%97%E9%80%8F/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipeyonbf9j20zk0m8e81.jpg" title="反序列化"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> web渗透</span><h3>反序列化</h3></a></div><div class="item right"><a href="/APT/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/Java%E5%8F%8D%E5%B0%84/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclhpw3lwj20zk0m8gvw.jpg" title="Java反射"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 代码审计</span><h3>Java反射</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%8F%8D%E5%B0%84"><span class="toc-number">1.</span> <span class="toc-text">Java反射</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.</span> <span class="toc-text">反射介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">反射常用方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">4.</span> <span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%B1%BB%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.1.</span> <span class="toc-text">获取类对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.</span> <span class="toc-text">获取类方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%B1%BB%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">4.3.</span> <span class="toc-text">获取类成员变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%B1%BB%E4%B8%8B%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">4.4.</span> <span class="toc-text">获取类下的构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E4%BB%BB%E6%84%8F%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1-%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-number">4.5.</span> <span class="toc-text">构造任意类的对象(实例化)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E4%BB%BB%E6%84%8F%E5%AE%9E%E4%BE%8B%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">4.6.</span> <span class="toc-text">调用任意实例类对象的方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C"><span class="toc-number">5.</span> <span class="toc-text">命令执行</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">5.1.</span> <span class="toc-text">普通调用方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E8%B0%83%E7%94%A8"><span class="toc-number">5.2.</span> <span class="toc-text">通过反射调用</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/APT/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/%E5%AE%A1%E8%AE%A1%E5%9F%BA%E7%A1%80/%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8/" rel="bookmark" title="idea基础使用">idea基础使用</a></li><li><a href="/APT/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/%E5%AE%A1%E8%AE%A1%E5%9F%BA%E7%A1%80/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/" rel="bookmark" title="动态代理">动态代理</a></li><li><a href="/APT/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/%E5%AE%A1%E8%AE%A1%E5%9F%BA%E7%A1%80/%E7%B1%BB%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/" rel="bookmark" title="类动态加载">类动态加载</a></li><li><a href="/APT/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/%E5%AE%A1%E8%AE%A1%E5%9F%BA%E7%A1%80/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" rel="bookmark" title="Java序列化和反序列化">Java序列化和反序列化</a></li><li class="active"><a href="/APT/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/%E5%AE%A1%E8%AE%A1%E5%9F%BA%E7%A1%80/Java%E5%8F%8D%E5%B0%84/" rel="bookmark" title="Java反射">Java反射</a></li><li><a href="/APT/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/%E5%AE%A1%E8%AE%A1%E5%9F%BA%E7%A1%80/JaveEE%E6%A0%B8%E5%BF%83/" rel="bookmark" title="10. JaveEE核心">10. JaveEE核心</a></li><li><a href="/APT/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/%E5%AE%A1%E8%AE%A1%E5%9F%BA%E7%A1%80/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" rel="bookmark" title="1. java类加载机制">1. java类加载机制</a></li><li><a href="/APT/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/%E5%AE%A1%E8%AE%A1%E5%9F%BA%E7%A1%80/sun.misc.Unsafe/" rel="bookmark" title="3. sun.misc.Unsafe">3. sun.misc.Unsafe</a></li><li><a href="/APT/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/%E5%AE%A1%E8%AE%A1%E5%9F%BA%E7%A1%80/Java%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/" rel="bookmark" title="4. java文件系统安全">4. java文件系统安全</a></li><li><a href="/APT/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/%E5%AE%A1%E8%AE%A1%E5%9F%BA%E7%A1%80/JDBC/" rel="bookmark" title="6. JDBC">6. JDBC</a></li><li><a href="/APT/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/%E5%AE%A1%E8%AE%A1%E5%9F%BA%E7%A1%80/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/" rel="bookmark" title="Tomcat内存马">Tomcat内存马</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="余星酒" data-src="/images/avatar.jpg"><p class="name" itemprop="name">余星酒</p><div class="description" itemprop="description">欢迎参观我的笔记空间 ~ 这里主要会记录一些安全相关的学习笔记 🌸</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">253</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">43</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">36</span> <span class="name">标签</span></a></div></nav><div class="social"></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/APT/web%E6%B8%97%E9%80%8F/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/APT/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/Java%E5%8F%8D%E5%B0%84/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/Network/" title="分类于 网络">网络</a> <i class="ic i-angle-right"></i> <a href="/categories/Network/%E6%B7%B1%E4%BF%A1%E6%9C%8D%E8%AE%BE%E5%A4%87/" title="分类于 深信服设备">深信服设备</a> <i class="ic i-angle-right"></i> <a href="/categories/Network/%E6%B7%B1%E4%BF%A1%E6%9C%8D%E8%AE%BE%E5%A4%87/%E5%AE%9E%E9%AA%8C/" title="分类于 实验">实验</a></div><span><a href="/Network/%E6%B7%B1%E4%BF%A1%E6%9C%8D%E8%AE%BE%E5%A4%87/%E5%AE%9E%E9%AA%8C/AF/AF%E9%83%A8%E7%BD%B2/" title="AF部署">AF部署</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/Other/011-%E5%8F%8D%E5%BC%B9shell/012-PHP%E8%84%9A%E6%9C%AC%E5%8F%8D%E5%BC%B9shell/" title="未命名">未命名</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/APT/" title="分类于 渗透测试">渗透测试</a> <i class="ic i-angle-right"></i> <a href="/categories/APT/web%E6%B8%97%E9%80%8F/" title="分类于 web渗透">web渗透</a></div><span><a href="/APT/web%E6%B8%97%E9%80%8F/XXE/" title="XXE">XXE</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Program/" title="分类于 编程">编程</a> <i class="ic i-angle-right"></i> <a href="/categories/Program/Golang/" title="分类于 Golang">Golang</a> <i class="ic i-angle-right"></i> <a href="/categories/Program/Golang/%E5%B8%B8%E7%94%A8%E5%BA%93/" title="分类于 常用库">常用库</a></div><span><a href="/Program/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/sync/" title="sync">sync</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Network/" title="分类于 网络">网络</a> <i class="ic i-angle-right"></i> <a href="/categories/Network/%E5%8D%8E%E4%B8%BA%E9%98%B2%E7%81%AB%E5%A2%99/" title="分类于 华为防火墙">华为防火墙</a> <i class="ic i-angle-right"></i> <a href="/categories/Network/%E5%8D%8E%E4%B8%BA%E9%98%B2%E7%81%AB%E5%A2%99/%E5%AE%9E%E9%AA%8C/" title="分类于 实验">实验</a></div><span><a href="/Network/%E5%8D%8E%E4%B8%BA%E9%98%B2%E7%81%AB%E5%A2%99/%E5%AE%9E%E9%AA%8C/%E9%98%B2%E7%81%AB%E5%A2%99%E5%8F%8C%E6%9C%BA%E7%83%AD%E5%A4%87/" title="防火墙双机热备">防火墙双机热备</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Network/" title="分类于 网络">网络</a> <i class="ic i-angle-right"></i> <a href="/categories/Network/%E6%B7%B1%E4%BF%A1%E6%9C%8D%E8%AE%BE%E5%A4%87/" title="分类于 深信服设备">深信服设备</a> <i class="ic i-angle-right"></i> <a href="/categories/Network/%E6%B7%B1%E4%BF%A1%E6%9C%8D%E8%AE%BE%E5%A4%87/AF/" title="分类于 AF">AF</a></div><span><a href="/Network/%E6%B7%B1%E4%BF%A1%E6%9C%8D%E8%AE%BE%E5%A4%87/%E6%B7%B1%E4%BF%A1%E6%9C%8D/AF/%E8%AE%A4%E8%AF%86AF/" title="认识AF">认识AF</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Program/" title="分类于 编程">编程</a> <i class="ic i-angle-right"></i> <a href="/categories/Program/Golang/" title="分类于 Golang">Golang</a> <i class="ic i-angle-right"></i> <a href="/categories/Program/Golang/%E5%9F%BA%E7%A1%80/" title="分类于 基础">基础</a></div><span><a href="/Program/golang/%E5%85%A5%E9%97%A8/%E5%8C%85%E7%9A%84%E6%93%8D%E4%BD%9C/" title="包的操作">包的操作</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Program/" title="分类于 编程">编程</a> <i class="ic i-angle-right"></i> <a href="/categories/Program/Golang/" title="分类于 Golang">Golang</a> <i class="ic i-angle-right"></i> <a href="/categories/Program/Golang/%E5%B8%B8%E7%94%A8%E5%BA%93/" title="分类于 常用库">常用库</a></div><span><a href="/Program/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/runtime/" title="runetime">runetime</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/PDCERF/" title="分类于 应急响应">应急响应</a> <i class="ic i-angle-right"></i> <a href="/categories/PDCERF/%E7%B3%BB%E7%BB%9F%E5%8A%A0%E5%9B%BA/" title="分类于 系统加固">系统加固</a></div><span><a href="/PDCERF/%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA/Linux%E5%8A%A0%E5%9B%BA/" title="Linux加固">Linux加固</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/PDCERF/" title="分类于 应急响应">应急响应</a> <i class="ic i-angle-right"></i> <a href="/categories/PDCERF/Windows%E5%BA%94%E6%80%A5%E7%AC%94%E8%AE%B0/" title="分类于 Windows应急笔记">Windows应急笔记</a></div><span><a href="/PDCERF/Windows%E5%AE%9E%E6%88%98%E7%AF%87/windows%E9%BB%91%E9%93%BE/" title="windows黑链">windows黑链</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">余星酒 @ 余星酒</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"APT/代码审计/Java代码审计/审计基础/Java反射/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->