<!-- build time:Thu Jan 18 2024 13:22:56 GMT+0800 (China Standard Time) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="余星酒" href="http://example.com/rss.xml"><link rel="alternate" type="application/atom+xml" title="余星酒" href="http://example.com/atom.xml"><link rel="alternate" type="application/json" title="余星酒" href="http://example.com/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="Golang,Golang入门进阶"><link rel="canonical" href="http://example.com/Program/golang/%E8%BF%9B%E9%98%B6/%E5%B9%B6%E5%8F%91/"><title>并发 - 进阶 - Golang - 编程 | 余星酒 = 余星酒 = 痴看年少风雨疾，一转本生蹉跎游</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">并发</h1><div class="meta"><span class="item" title="创建时间：2023-01-23 08:56:49"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2023-01-23T08:56:49+08:00">2023-01-23</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">余星酒</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giclhfehz7j20zk0m8u0x.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giclh3brzpj20zk0m8ann.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giciundwu5j20zk0m8n9e.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipexoj0moj20zk0m8kgu.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipetv6p75j20zk0m8x6p.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gicitht3xtj20zk0m8k5v.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/Program/" itemprop="item" rel="index" title="分类于 编程"><span itemprop="name">编程</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/Program/Golang/" itemprop="item" rel="index" title="分类于 Golang"><span itemprop="name">Golang</span></a><meta itemprop="position" content="2"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/Program/Golang/%E8%BF%9B%E9%98%B6/" itemprop="item" rel="index" title="分类于 进阶"><span itemprop="name">进阶</span></a><meta itemprop="position" content="3"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/Program/golang/%E8%BF%9B%E9%98%B6/%E5%B9%B6%E5%8F%91/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="余星酒"><meta itemprop="description" content="痴看年少风雨疾，一转本生蹉跎游, 欢迎参观我的笔记空间 ~ 这里主要会记录一些安全相关的学习笔记 🌸"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="余星酒"></span><div class="body md" itemprop="articleBody"><h1 id="并发基础"><a href="#并发基础" class="headerlink" title="并发基础"></a>并发基础</h1><p>并发变成开发将一个过程按照并行算法拆分成多个可独立执行代码块</p><h2 id="顺序、并发与并行"><a href="#顺序、并发与并行" class="headerlink" title="顺序、并发与并行"></a>顺序、并发与并行</h2><ol><li>顺序是指发起执行的程序只能有一个</li><li>并发是指同时发起执行（同时处理）的程序可以有多个</li><li>并行是指同时执行（同时做）的程序可以有多个</li></ol><h1 id="例程"><a href="#例程" class="headerlink" title="例程"></a>例程</h1><p>在Go语言中每个并发执行的单元叫Goroutine，使用<code>go</code>关键字后接函数来创建一个Goroutine</p><h2 id="例程的创建"><a href="#例程的创建" class="headerlink" title="例程的创建"></a>例程的创建</h2><pre><code class="go">package main


func PrintString(str string) &#123;
    for i := 1; i &lt; 10; i++ &#123;
        fmt.Printf(&quot;%s =&gt; %d\n&quot;, str, i)
    &#125;
&#125;

func main() &#123;

    go demo6.PrintString(&quot;goroutine&quot;)

    demo6.PrintString(&quot;main&quot;)

&#125;

/*
main =&gt; 1
main =&gt; 2
main =&gt; 3
main =&gt; 4
main =&gt; 5
main =&gt; 6
main =&gt; 7
main =&gt; 8
main =&gt; 9
goroutine =&gt; 1
*/
</code></pre><blockquote><p>为什么会出现上述情况，这是因为<code>main</code>中是主例程，当主例程执行完成后，其他例程也会自动结束，不管是否正在执行</p></blockquote><h3 id="闭包陷阱"><a href="#闭包陷阱" class="headerlink" title="闭包陷阱"></a>闭包陷阱</h3><p>因为闭包使用函数外变量，当例程执行时，外部变量已经发生变化，导致打印的内容不正确，可使用在创建例程时通过函数传递参数（值拷贝）方式避免</p><pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func main() &#123;
    
    for i := 0; i &lt; 10; i++ &#123;
        go func() &#123;
            fmt.Println(i)
        &#125;()
    &#125;

    time.Sleep(time.Second)

&#125;

/*
10
10
10
10
10
6
10
10
8
10
*/
</code></pre><blockquote><p>为什么会打印出10，这是因为例程还没有启动时，本该打印1，结果因为循环变量变为2，当变量为10退出循环时，例程恰好启动，输出10</p></blockquote><pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func main() &#123;

    for i := 0; i &lt; 10; i++ &#123;
        go func(j int) &#123;
            fmt.Println(j)
        &#125;(i)
    &#125;

    time.Sleep(time.Second)

&#125;

/*
6
9
7
8
0
2
4
5
1
3
*/
</code></pre><h2 id="等待例程"><a href="#等待例程" class="headerlink" title="等待例程"></a>等待例程</h2><p>main函数也是由一个例程启动执行，这个例程称为主例程，其他的例程称为工作例程，主例程结束后工作例程也会随之销毁，使用sync.WaitGroup来维护执行例程执行状态</p><h3 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h3><blockquote><p>WaitGroup实现同步</p><p>var wg sync.WaitGroup</p></blockquote><pre><code class="go">Add(n) // 添加n信号

Done() // 处理完成一个信号

Wait() // 等待计数器归零，当所有信号完成处理就结束
</code></pre><p>查看添加WaitGroup和不添加WaitGroup的区别</p><p><strong>没有使用WaitGroup</strong></p><pre><code class="go">package main

import &quot;fmt&quot;

func send(i int) &#123;
    fmt.Printf(&quot;i : %d\n&quot;, i)
&#125;

func main() &#123;
    for i := 0; i &lt; 10; i++ &#123;
        go send(i)
    &#125;

    fmt.Println(&quot;end~~~&quot;)
&#125;
</code></pre><pre><code class="go">i : 0
i : 1
end~~~
</code></pre><pre><code class="go">i : 4
end~~~
</code></pre><p><strong>使用WaitGroup</strong></p><pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;sync&quot;
)

var wp sync.WaitGroup

func send(i int) &#123;
    defer wp.Done() // 完成任务就-1
    fmt.Println(&quot;Send : &quot;, i)
&#125;

func main() &#123;
    for i := 0; i &lt; 10; i++ &#123;
        go send(i)
        wp.Add(1) // 开启一个任务就+1
    &#125;
    wp.Wait() // 等待所有协成
    fmt.Println(&quot;end~~~&quot;)
&#125;
</code></pre><pre><code class="go">Send :  1
Send :  9
Send :  7
Send :  3
Send :  8
Send :  0
Send :  2
Send :  4
Send :  5
Send :  6
end~~~
</code></pre><h3 id="管道实现等待"><a href="#管道实现等待" class="headerlink" title="管道实现等待"></a>管道实现等待</h3><blockquote><p>管道如果能读取到数据，说明例程已经执行完成</p></blockquote><pre><code class="go">package main

import &quot;fmt&quot;


func main() &#123;

    channel := make(chan int)

    for i := 0; i &lt; 2; i++ &#123;
        go func(index int) &#123;
            for i := 0; i &lt; 4; i++ &#123;
                fmt.Printf(&quot;%d次 =&gt; %d\n&quot;, index, i)
            &#125;
            channel &lt;- 0
        &#125;(i)
    &#125;

    for i := 0; i &lt; 2; i++ &#123;
        &lt;-channel
    &#125;

&#125;
/*
1次 =&gt; 0
1次 =&gt; 1
1次 =&gt; 2
1次 =&gt; 3
0次 =&gt; 0
0次 =&gt; 1
0次 =&gt; 2
0次 =&gt; 3
*/
</code></pre><p>这里创建了3个例程，其中每个例程都活通过管道传递数据，此时在创建3个管道读取，即可实现等待例程执行完的效果</p><h2 id="例程间通信"><a href="#例程间通信" class="headerlink" title="例程间通信"></a>例程间通信</h2><p>分为两种，一种是共享数据【同步】（互斥锁、原子操作），一种是通道【异步】（channel）</p><h3 id="Mutext互斥锁实现同步"><a href="#Mutext互斥锁实现同步" class="headerlink" title="Mutext互斥锁实现同步"></a>Mutext互斥锁实现同步</h3><blockquote><p>var lock sync.Mutex</p><p>可以使用Mutext互斥锁的方式实现同步</p></blockquote><p><strong>案例</strong> : 多个协程去访问共享资源</p><ol><li>使用sync.WaitGroup</li></ol><pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;sync&quot;
    &quot;time&quot;
)

var i int = 100
var wg sync.WaitGroup

func add() &#123;
    wg.Done()
    i += 1
    fmt.Println(&quot;i++ : &quot;, i)
    time.Sleep(time.Millisecond * 10)
&#125;
func sub() &#123;
    wg.Done()
    i -= 1
    fmt.Println(&quot;i-- : &quot;, i)
    time.Sleep(time.Millisecond * 20)
&#125;
func main() &#123;
    for i := 0; i &lt; 100; i++ &#123;
        wg.Add(1)
        go add()
        wg.Add(1)
        go sub()
    &#125;
    wg.Wait()
    fmt.Println(&quot;i : &quot;, i)
&#125;
</code></pre><pre><code>i-- :  99
i++ :  101
i-- :  100
i++ :  101
i-- :  100
i :  101 // 最终结果可能会发生异常
</code></pre><ol start="2"><li>使用sync.WaitGroup + sync.Mutex</li></ol><pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;sync&quot;
    &quot;time&quot;
)

var i int = 100
var wg sync.WaitGroup
var lock sync.Mutex

func add() &#123;
    lock.Lock()
    wg.Done()
    i += 1
    fmt.Println(&quot;i++ : &quot;, i)
    time.Sleep(time.Millisecond * 10)
    lock.Unlock()
&#125;
func sub() &#123;
    lock.Lock()
    wg.Done()
    i -= 1
    fmt.Println(&quot;i-- : &quot;, i)
    time.Sleep(time.Millisecond * 20)
    lock.Unlock()
&#125;
func main() &#123;
    for i := 0; i &lt; 100; i++ &#123;
        wg.Add(1)
        go add()
        wg.Add(1)
        go sub()
    &#125;
    wg.Wait()
    fmt.Println(&quot;i : &quot;, i)
&#125;
</code></pre><pre><code>i-- :  100
i++ :  101
i-- :  100
i++ :  101
i-- :  100
i :  100
</code></pre><p>如果在加锁和解锁中间的代码发生了错误，导致无法及时解锁，如果直接使用<code>defer</code>，还是不行，因为defer执行的原则是函数结束后才会调用defer，那么可以使用匿名函数</p><pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;sync&quot;
    &quot;time&quot;
)

var i int = 100
var wg sync.WaitGroup
var lock sync.Mutex

func add() &#123;

    func() &#123;
        lock.Lock()
        i += 1
        fmt.Println(&quot;i++ : &quot;, i)
        time.Sleep(time.Millisecond * 10)
        wg.Done()
        defer lock.Unlock() // 这样就可以在函数执行完成后，自动调用defer
    &#125;()

&#125;
func sub() &#123;
    func() &#123;
        lock.Lock()
        i -= 1
        fmt.Println(&quot;i-- : &quot;, i)
        time.Sleep(time.Millisecond * 10)
        wg.Done()
        defer lock.Unlock()
    &#125;()
&#125;

func main() &#123;
    wg.Add(200)
    for i := 0; i &lt; 100; i++ &#123;
        go add()
        go sub()
    &#125;
    wg.Wait()
    fmt.Println(&quot;i : &quot;, i)
&#125;
</code></pre><h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><p>基本的原子操作</p><pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;sync/atomic&quot;
    &quot;time&quot;
)

var num int32 = 100

func add() &#123;
    atomic.AddInt32(&amp;num, 1)
&#125;
func sub() &#123;
    atomic.AddInt32(&amp;num, -2)
&#125;

func main() &#123;
    for i := 0; i &lt; 100; i++ &#123;
        go add()
        go sub()
    &#125;
    time.Sleep(time.Second)
    fmt.Println(num)
&#125;
</code></pre><p>atomic提供的原子操作能够确保任一时刻只有goroutine对变量进行操作，善用atomic能够避免程序中出现大量的锁操作</p><p>atomic常见操作有</p><ol><li>增减</li><li>载入</li><li>比较并交换 cas</li><li>交换</li><li>存储</li></ol><h4 id="增减操作"><a href="#增减操作" class="headerlink" title="增减操作"></a>增减操作</h4><p>atomic包中提供了如下以Add为前缀的增减操作</p><blockquote><p>AddInt32()</p><p>AddInt64()</p><p>AddUint32()</p><p>AddUint64()</p><p>AddUintptr()</p></blockquote><pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;sync/atomic&quot;
)

var num int32 = 100

func add() &#123;
    atomic.AddInt32(&amp;num, 1)
    fmt.Println(&quot;num++ : &quot;, num)
&#125;
func sub() &#123;
    atomic.AddInt32(&amp;num, -1)
    fmt.Println(&quot;num-- : &quot;, num)
&#125;

func main() &#123;
    add()
    fmt.Println(&quot;num : &quot;, num)
    sub()
    fmt.Println(&quot;num : &quot;, num)
&#125;

/*
num++ :  101
num :  101
num-- :  100
num :  100
*/
</code></pre><h4 id="载入操作"><a href="#载入操作" class="headerlink" title="载入操作"></a>载入操作</h4><blockquote><p>atomic.LoadInt32()</p><p>atomic.LoadInt64()</p><p>atomic.LoadUint32()</p><p>atomic.LoadUint64()</p><p>atomic.LoadPointer()</p><p>atomic.LoadUpointer()</p></blockquote><blockquote><p>atomic.StoreInt32()</p><p>atomic.StoreInt64()</p><p>atomic.StoreUint32()</p><p>atomic.StoreUint64()</p><p>atomic.StorePointer()</p><p>atomic.storeUintptr()</p></blockquote><pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;sync/atomic&quot;
)

var atomicLSNum int32 = 100

func main() &#123;
    atomic.LoadInt32(&amp;atomicLSNum)
    fmt.Println(&quot;atomicLSNum : &quot;, atomicLSNum)
    atomic.StoreInt32(&amp;atomicLSNum, 250)
    fmt.Println(&quot;atomicLSNum : &quot;, atomicLSNum)
&#125;

/*
atomicLSNum :  100
atomicLSNum :  250
*/
</code></pre><h4 id="比较并交换-cas"><a href="#比较并交换-cas" class="headerlink" title="比较并交换 cas"></a>比较并交换 cas</h4><p>该操作在进行交换前首先确保变量的值未被更改，即仍然保持参数old所记录的值，满足此前提下才进行交换操作，CAS的做法类似操作数据库时常见的乐观锁机制</p><blockquote><p>atomic.CompareAndSwapInt32()</p><p>atomic.CompareAndSwapInt64()</p><p>atomic.CompareAndSwapUint32()</p><p>atomic.CompareAndSwapUint64()</p><p>atomic.CompareAndSwapPointer()</p></blockquote><pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;sync/atomic&quot;
)

func main() &#123;
    var i int64 = 123
    ok := atomic.CompareAndSwapInt64(&amp;i, 123, 321)
    fmt.Println(&quot;bool : &quot;, ok)
    fmt.Println(&quot;values : &quot;, i)
&#125;
/*
bool :  true
values :  321
*/
</code></pre><h4 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h4><blockquote><p>atomic.SwapInt32()</p><p>atomic.SwapInt54()</p><p>atomic.SwapUint32()</p><p>atomic.SwapUint64()</p><p>atomic.SwapPointer()</p><p>atomic.SwapUintptr()</p></blockquote><p>相对于CAS，明显此类操作更为暴力直接，并不管变量的旧值是否被改变，直接赋予新值然后返回被替换的值</p><h4 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h4><p>确保了变量的原子性，避免其他操作读到了修改变量过程中的脏数据</p><blockquote><p>atomic.StoreInte32()</p><p>atomic.StoreInte64()</p><p>atomic.StoreUinte32()</p><p>atomic.StoreUinte64()</p><p>atomic.StorePointer()</p><p>atomic.StoreUintptr()</p></blockquote><h1 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h1><ol><li><p>Go提供了一种称为通道的机制，用于在gorountine之间共享数据，当作为goroutine执行并发活动时，需要在goroutine之间共享资源或数据，通道充当goroutine之间的管道并提供一种机制来保证同步交换</p></li><li><p>需要在声明通道时指定数据类型，可以共享内置、命名、结构和引用类型的值和指针，数据在通道上传递 （在任何给定时间只有一个goroutine可以访问数据项，因此按照设计不会发生数据竞争）</p></li><li><p>根据数据交换的行为，有两种类型的通道 : <code>无缓冲通道</code>和<code>缓冲通道</code></p><ol><li>无缓冲通道用于执行goroutine之间的同步通信，无缓冲通道保证在发送和接收发生的瞬间执行两个goroutine之间的交换</li><li>缓冲通道用于执行异步通信，缓冲通道没有这样的保证</li></ol></li></ol><h2 id="channel创建"><a href="#channel创建" class="headerlink" title="channel创建"></a>channel创建</h2><blockquote><p>不带缓冲区</p><p>写入时，没有其他例程读，会阻塞，读取时，没有其他例程写，会阻塞</p><p>带缓冲区</p><p>写入时，缓冲区已满时，没有其他例程读，会阻塞，读取时，没有数据，没有其他例程写，会阻塞</p></blockquote><p>通道由 make 函数创建，该函数指定 chan 关键字和通道元素类型</p><h3 id="无缓冲通道"><a href="#无缓冲通道" class="headerlink" title="无缓冲通道"></a>无缓冲通道</h3><p>在无缓冲通道中，在接收到任何值之前没有能力保存它，在这种类型的通道中，发送和接收goroutine在任何发送或接收操作完成之前的同一时刻都准备就休，如果两个goroutine没有在同一时刻准备好，则通道会让执行其各自发送或接收操作的goroutine首先等待，同步是通道上发送和接收之间交互的基础，没有另一个就不可能发生</p><p>创建一个无缓冲通道</p><pre><code class="go">Unbuffered := make(chan int)
</code></pre><h3 id="缓冲通道"><a href="#缓冲通道" class="headerlink" title="缓冲通道"></a>缓冲通道</h3><p>在缓冲通道中，有能力在接收到一个或多个值之前保存它们，在这种类型的通道中，不强制goroutine在同一时刻准备好执行发送和接收，当发送或接收阻塞时也有不同的条件，只有当通道中没有要接收的值时，接收才会阻塞，仅当没有可用缓冲区来防止正在发送的值时，发送才会阻塞</p><p>创建一个有缓存通道</p><pre><code class="go">buffered := make(chan int, 10)
</code></pre><p>使用内置函数 <code>make</code> 创建无缓冲通道，第一个参数是关键字 <code>chan</code>， 然后是<code>通道允许交换的数据类型</code>（第三个<code>数据大小</code>）</p><h3 id="读写管道"><a href="#读写管道" class="headerlink" title="读写管道"></a>读写管道</h3><p>通过另一个管道对其进行赋值</p><pre><code class="go">channel  := make(chan int, 10)
var readonly &lt;-chan int  // 只读
var writeonly chan&lt;- int // 只写

readonly = channel
writeonly = channel
</code></pre><pre><code class="go">package main

import &quot;fmt&quot;

func main() &#123;

    channel := make(chan int, 4)

    channel &lt;- 2

    w := func(channel chan&lt;- int, num int) &#123;
        channel &lt;- num
    &#125;

    r := func(channel &lt;-chan int) &#123;
        fmt.Println(&lt;-channel)
    &#125;

    r(channel) // 2
    w(channel, 12)
    r(channel) // 12

&#125;
</code></pre><h2 id="channel运算符"><a href="#channel运算符" class="headerlink" title="channel运算符"></a>channel运算符</h2><ol><li>将值发送到通道的代码块运算符 <code>通道变量 &lt;- 值</code></li></ol><pre><code>goroutine1 := make(chan string, 5) // 创建字符串缓存通道
goroutine1 &lt;- &quot;Hello&quot; // 通过通道发送字符串
</code></pre><ol start="2"><li>从通道获取数据的运算符 <code>接收者变量 &lt;- 通道变量</code></li></ol><pre><code>data := &lt;- goroutine1 // 从通道获取字符串
</code></pre><ol start="3"><li>关闭管道</li></ol><pre><code class="go">close(goroutinel)
</code></pre><h2 id="通道的发送和接收特性"><a href="#通道的发送和接收特性" class="headerlink" title="通道的发送和接收特性"></a>通道的发送和接收特性</h2><ol><li>对于同一个通道，发送操作之间是互斥的，接收操作之间也是互斥的</li><li>发送操作和接收操作中对元素值的处理都是不可分割的</li><li>发送操作在完全完成之前会被阻塞，接收操作也是如此</li></ol><pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;math/rand&quot;
    &quot;time&quot;
)

var values = make(chan int)

func showMsg() &#123;
    rand.Seed(time.Now().UnixNano())
    value := rand.Intn(10)
    fmt.Println(&quot;Send : &quot;, value)
    time.Sleep(time.Millisecond * 2000)
    values &lt;- value

&#125;
func main() &#123;
    go showMsg()
    value := &lt;-values
    fmt.Println(&quot;Receive : &quot;, value)
    defer close(values)
&#125;
</code></pre><pre><code class="go">Send :  9
Receive :  9
</code></pre><p>管道关闭后，读取管道返回数据，不在进行阻塞</p><p>在读取管道的时候，利用第二个参数来判断是不是因为管道关闭导致的返回，管道关闭返回false</p><pre><code class="go">_, ok := &lt;-channel
</code></pre><h2 id="channel遍历"><a href="#channel遍历" class="headerlink" title="channel遍历"></a>channel遍历</h2><h3 id="if-for"><a href="#if-for" class="headerlink" title="if+for"></a>if+for</h3><pre><code class="go">package main

import &quot;fmt&quot;

var c = make(chan int)

func main() &#123;

    go func() &#123;
        for i := 0; i &lt; 10; i++ &#123;
            c &lt;- i
        &#125;
        close(c)
    &#125;()
    for &#123;
        value, ok := &lt;-c
        if ok &#123;
            fmt.Println(value)
        &#125; else &#123;
            break
        &#125;
    &#125;
&#125;
</code></pre><pre><code>0
1
2
3
4
5
6
7
8
9
</code></pre><h3 id="range"><a href="#range" class="headerlink" title="range"></a>range</h3><pre><code class="go">package main

import (
    &quot;fmt&quot;
)

var c = make(chan int)

func main() &#123;

    go func() &#123;
        for i := 0; i &lt; 10; i++ &#123;
            c &lt;- i
        &#125;
        close(c)
    &#125;()
    for value := range c &#123;
        fmt.Println(value)
    &#125;
&#125;
</code></pre><pre><code>0
1
2
3
4
5
6
7
8
9
</code></pre><h1 id="select-switch"><a href="#select-switch" class="headerlink" title="select&amp;switch"></a>select&amp;switch</h1><ol><li>select是Go中的一个控制结构，类似Switch语句，用于处理异步IO操作，select会监听case语句中的channel的读写操作，当case中channel读写操作为非阻塞状态（即能读写）时，将会触发相应的动作</li></ol><blockquote><p>select中的case语句必须是一个channel操作</p><p>select中的default子句总是可运行的</p></blockquote><ol start="2"><li><p>如果有多个case都可以运行，select会随机公平地选出一个执行，其他不会执行</p></li><li><p>如果没有可运行的case语句，且有default语句，那么就会执行default的动作</p></li><li><p>如果没有可运行的case语句，且没有default语句，select将阻塞，直到某个case通信可以运行</p></li></ol><pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;runtime&quot;
    &quot;time&quot;
)

var (
    chanInt    = make(chan int)
    chanString = make(chan string)
)

var num = 0

func main() &#123;

    runtime.GOMAXPROCS(3) // 使用3核CPU
    go func() &#123;
        chanInt &lt;- 123
        chanString &lt;- &quot;Hello&quot;
        close(chanInt)
        close(chanString)
    &#125;()
    for &#123;
        select &#123;
        case r := &lt;-chanInt:
            fmt.Printf(&quot;chanInt : %d\n&quot;, r)
        case r := &lt;-chanString:
            fmt.Printf(&quot;chanString : %s\n&quot;, r)
            num++
        default:
            fmt.Println(&quot;default…………&quot;)
        &#125;
        time.Sleep(time.Millisecond * 20)
        if num == 5 &#123;
            break
        &#125;
    &#125;

&#125;
</code></pre><pre><code>default…………
chanInt : 123
chanString : Hello
chanString : 
chanString : 
chanString : 
chanInt : 0
chanString : 
</code></pre><h1 id="time"><a href="#time" class="headerlink" title="time"></a>time</h1><p><code>time.After()</code> 和 <code>time.Tick()</code> 这两个函数都会返回一个只读管道 <code>&lt;-chan Time</code></p><h2 id="time-After"><a href="#time-After" class="headerlink" title="time.After()"></a>time.After()</h2><blockquote><p>间隔 n 秒后结束</p></blockquote><pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func main() &#123;
    fmt.Println(time.Now())
    &lt;-time.After(time.Second * 2)
    fmt.Println(time.Now())
&#125;

/*
2022-12-01 13:48:56.1661171 +0800 CST m=+0.002714901
2022-12-01 13:48:58.1781814 +0800 CST m=+2.014779201
*/
</code></pre><p><strong>模拟规定时间内停止</strong></p><ol><li>使用一个例程监视另外一个</li></ol><pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;math/rand&quot;
    &quot;time&quot;
)

func main() &#123;
    result := make(chan interface&#123;&#125;)
    timeout := make(chan struct&#123;&#125;)

    go func() &#123;
        time.Sleep(time.Second * 5)
        timeout &lt;- struct&#123;&#125;&#123;&#125;
    &#125;()

    go func() &#123;
        r := rand.Intn(10)
        fmt.Println(r)
        time.Sleep(time.Second * time.Duration(r))
        result &lt;- r
    &#125;()

    select &#123;
        case v := &lt;-result :
            fmt.Println(v)
        case v:= &lt;-timeout:
            fmt.Printf(&quot;已经超时 %#v\n&quot;, v)
    &#125;
&#125;
</code></pre><ol start="2"><li>使用time.After()实现此功能</li></ol><pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;math/rand&quot;
    &quot;time&quot;
)

func main() &#123;
    result := make(chan interface&#123;&#125;)

    go func() &#123;
        r := rand.Intn(10)
        fmt.Println(r)
        time.Sleep(time.Second * time.Duration(r))
        result &lt;- r
    &#125;()

    select &#123;
    case v := &lt;-time.After(time.Second * 5):
        fmt.Printf(&quot;已经超时 %#v\n&quot;, v)
    case v := &lt;-result:
        fmt.Println(v)
    &#125;
&#125;
</code></pre><h2 id="time-Tick"><a href="#time-Tick" class="headerlink" title="time.Tick()"></a>time.Tick()</h2><blockquote><p>定时 n 秒执行</p></blockquote><pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func timeTicker(interval time.Duration) &lt;-chan time.Time &#123;
    channel := make(chan time.Time)
    go func() &#123;
        for &#123; // 定时 interval 秒后往管道写入数据     
            time.Sleep(interval)
            channel &lt;- time.Now()
        &#125;
    &#125;()
    return channel

&#125;

func main() &#123;
    for t := range timeTicker(time.Second * 1) &#123; // 循环读取获取通道中的数据
        fmt.Println(t)
    &#125;
&#125;
/*
2023-09-03 21:25:10.4093187 +0800 CST m=+1.007206901
2023-09-03 21:25:11.4185214 +0800 CST m=+2.016409601
2023-09-03 21:25:12.4324947 +0800 CST m=+3.030382901
2023-09-03 21:25:13.4425494 +0800 CST m=+4.040437601
………………
*/
</code></pre><h2 id="time-Ticker"><a href="#time-Ticker" class="headerlink" title="time.Ticker"></a>time.Ticker</h2><p><code>time.Ticker</code>是一个结构体，<code>time.NewTicker()</code>创建一个Ticker，也是每间隔 n 秒执行一次，如果想要遍历就必须得拿到其对应的管道 <code>Ticker.C</code>，如果想要在某一时刻关闭，可以使用<code>Ticker.Stop()</code></p><pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func main() &#123;
    conster := 1
    timer := time.NewTicker(time.Second * 1) // 每延迟1秒执行
    for _ = range timer.C &#123;

        if conster &lt;= 5 &#123;
            fmt.Println(conster)
        &#125; else &#123;
            timer.Stop() // 关闭Ticker
            break
        &#125;
        conster++
    &#125;
&#125;
/*
1
2
3
4
5
*/
</code></pre><p>实现一个随机发送数据</p><pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

var values = make(chan int)

func main() &#123;
    timer := time.NewTicker(time.Second)
    go func() &#123;
        for _ = range timer.C &#123;
            select &#123;
            case values &lt;- 1:
            case values &lt;- 2:
            case values &lt;- 3:
            &#125;
        &#125;
    &#125;()

    num := 0
    for v := range values &#123;
        fmt.Println(&quot;v : &quot;, v)
        num += v
        if num &gt;= 12 &#123;
            fmt.Println(num)
            break
        &#125;
    &#125;
&#125;
/*
v :  3
v :  1
v :  2
v :  2
v :  2
v :  2
12
*/
</code></pre><h2 id="time-Timer"><a href="#time-Timer" class="headerlink" title="time.Timer"></a>time.Timer</h2><p>Timer顾名思义，就是定时器的意思，可以实现一些定时操作，内部也是通过channel来实现的</p><ol><li>直接延时</li></ol><blockquote><p>使用time.Sleep()</p></blockquote><pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func main() &#123;
    fmt.Println(time.Now())
    time.Sleep(time.Second * 2)
    fmt.Println(time.Now())
&#125;
</code></pre><pre><code class="go">2022-12-01 13:41:20.9241654 +0800 CST m=+0.002567701
2022-12-01 13:41:22.9509834 +0800 CST m=+2.029385701
</code></pre><p><code>&lt;-time.NewTimer().C</code></p><pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func main() &#123;
    fmt.Println(time.Now())
    timer := time.NewTimer(time.Second * 2)
    &lt;-timer.C
    fmt.Println(time.Now())
&#125;
</code></pre><pre><code class="go">2022-12-01 13:45:09.1506624 +0800 CST m=+0.002645601
2022-12-01 13:45:11.1736947 +0800 CST m=+2.025677901
</code></pre><ol start="2"><li>停止定时器</li></ol><p>不添加停止定时器</p><pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func main() &#123;
    timer := time.NewTimer(time.Second * 2)
    go func() &#123;
        &lt;-timer.C
        fmt.Println(&quot;func end...&quot;)
    &#125;()
    time.Sleep(time.Second * 3)
    fmt.Println(&quot;main end...&quot;)
&#125;
</code></pre><pre><code class="go">func end...
main end...
</code></pre><p>添加停止定时器</p><pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func main() &#123;
    timer := time.NewTimer(time.Second * 2)
    go func() &#123;
        &lt;-timer.C
        fmt.Println(&quot;func end...&quot;)
    &#125;()
    stop := timer.Stop()
    if stop &#123;
        fmt.Println(&quot;timer stop...&quot;)
    &#125;
    time.Sleep(time.Second * 3)
    fmt.Println(&quot;main end...&quot;)

&#125;
</code></pre><pre><code class="go">timer stop...
main end...
</code></pre><p>重新设置定时器</p><pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func main() &#123;
    fmt.Println(time.Now())
    timer := time.NewTimer(time.Second * 5) // 设置延时为5秒
    timer.Reset(time.Second * 3)            // 重新设置延时为3秒
    &lt;-timer.C
    fmt.Println(time.Now())
&#125;
</code></pre><pre><code class="go">2022-12-01 13:57:26.8418402 +0800 CST m=+0.002787201
2022-12-01 13:57:29.863725 +0800 CST m=+3.024672001
</code></pre><h1 id="对象池"><a href="#对象池" class="headerlink" title="对象池"></a>对象池</h1><h2 id="sync-Pool"><a href="#sync-Pool" class="headerlink" title="sync.Pool"></a>sync.Pool</h2><pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;strconv&quot;
    &quot;sync&quot;
)

type proxy struct &#123;
    index int
    addr  string
&#125;

func getAddr(url string) []string &#123;
    urls := make([]string, 0, 100)
    str := &quot;192.168.1.&quot;
    for i := 1; i &lt;= 10; i++ &#123;
        urls = append(urls, str+strconv.Itoa(i))
    &#125;
    return urls
&#125;

func main() &#123;
    urls := getAddr(&quot;http://www.baidu.com&quot;)
    i := 0
    pool := sync.Pool&#123;
        New: func() interface&#123;&#125; &#123;
            i++
            fmt.Println(&quot;new : &quot;, i)
            return &amp;proxy&#123;
                i,
                urls[i-1],
            &#125;
        &#125;,
    &#125;
    proxy_test := pool.Get() // 获取对象池中的对象，如果没有会new一个
    fmt.Println(proxy_test)
    pool.Put(proxy_test) // 将获取的对象返回创建的对象池

    proxy_test = pool.Get()
    fmt.Println(proxy_test) // 再次获取对象时，会去对象池找，里面存在一个刚刚放回去的就不会再new一个

    proxy_test = pool.Get() // 取出后再次Get,没有找到就会再次new
    fmt.Println(proxy_test)

&#125;
/*
new :  1
&amp;&#123;1 192.168.1.1&#125;
&amp;&#123;1 192.168.1.1&#125;
new :  2        
&amp;&#123;2 192.168.1.2&#125;
*/
</code></pre><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><h2 id="使用WaitGroup实现统计行数"><a href="#使用WaitGroup实现统计行数" class="headerlink" title="使用WaitGroup实现统计行数"></a>使用WaitGroup实现统计行数</h2><pre><code class="go">package main

import (
    &quot;bufio&quot;
    &quot;fmt&quot;
    &quot;io/fs&quot;
    &quot;os&quot;
    &quot;path/filepath&quot;
    &quot;strings&quot;
    &quot;sync&quot;
    &quot;sync/atomic&quot;
)

func readLine(path string) int &#123;

    ctx := 0
    f, err := os.Open(path)
    if err != nil &#123;
        fmt.Println(err)
    &#125;
    defer f.Close()

    scanner := bufio.NewScanner(f)
    for scanner.Scan() &#123;
        s := scanner.Text()
        s = strings.TrimSpace(s)
        if s == &quot;&quot; || strings.HasPrefix(s, &quot;//&quot;) &#123; // 判断行不为空，且不包含 //注释
            continue
        &#125;
        ctx += 1
    &#125;
    return ctx
&#125;

func main() &#123;

    p, _ := filepath.Abs(&quot;.&quot;)
    dir := &quot;.&quot;
    var tools int64 = 0
    fmt.Printf(&quot;%T\n&quot;, tools)
    var wg sync.WaitGroup

    filepath.Walk(dir, func(path string, info fs.FileInfo, err error) error &#123;
        path = filepath.Join(p, path) // 拼接路径

        if filepath.Ext(path) == &quot;.go&quot; &amp;&amp; !info.IsDir() &#123; // 判断是否为go文件，且不是目录
            wg.Add(1) // 添加信号
            go func() &#123;
                atomic.AddInt64(&amp;tools, int64(readLine(path))) // 原子操作，也可以使用加锁解锁来保证准确
                wg.Done() // 删除信号
            &#125;()
        &#125;
        return nil
    &#125;)

    wg.Wait()

    fmt.Println(tools)
&#125;
</code></pre><h2 id="使用管道实现统计行数"><a href="#使用管道实现统计行数" class="headerlink" title="使用管道实现统计行数"></a>使用管道实现统计行数</h2><pre><code class="go">package main

import (
    &quot;bufio&quot;
    &quot;fmt&quot;
    &quot;io/fs&quot;
    &quot;os&quot;
    &quot;path/filepath&quot;
    &quot;strings&quot;
    &quot;sync&quot;
    &quot;sync/atomic&quot;
)

// 测试注释
func readLine(path string) int &#123;

    ctx := 0
    f, err := os.Open(path)
    if err != nil &#123;
        fmt.Println(err)
    &#125;
    defer f.Close()

    scanner := bufio.NewScanner(f)
    for scanner.Scan() &#123;
        s := scanner.Text()
        s = strings.TrimSpace(s)
        if s == &quot;&quot; || strings.HasPrefix(s, &quot;//&quot;) &#123;
            continue
        &#125;
        ctx += 1
    &#125;
    return ctx
&#125;


func main() &#123;

    p, _ := filepath.Abs(&quot;.&quot;)
    dir := &quot;.&quot;
    tools := 0
    var wg sync.WaitGroup

    fmt.Printf(&quot;%T\n&quot;, tools)

    channel := make(chan int, 5)
    exit := make(chan bool)

    filepath.Walk(dir, func(path string, info fs.FileInfo, err error) error &#123;
        path = filepath.Join(p, path)

        if filepath.Ext(path) == &quot;.go&quot; &amp;&amp; !info.IsDir() &#123;
            wg.Add(1)
            go func() &#123;
                c := readLine(path)
                channel &lt;- c // 将返回结果传递到通道中
                wg.Done()
            &#125;()
        &#125;
        return nil
    &#125;)

    go func() &#123;
        for e := range channel &#123;
            tools += e
        &#125;
        exit &lt;- false // 通过将数据传入管道，来达到无法让主例程结束
    &#125;()

    wg.Wait()
    close(channel) // 在wg.Wait()之后关闭channel通道，确保在filepath.Walk执行完成后关闭通道

    &lt;-exit // 确保遍例程能够在主例程结束之前完成，&lt;-exit会一直堵塞，直到没有数据写入

    fmt.Println(tools)
&#125;
</code></pre><h2 id="实现定时器"><a href="#实现定时器" class="headerlink" title="实现定时器"></a>实现定时器</h2><blockquote><p>定时 10 秒后结束</p></blockquote><ul><li>time.After()</li></ul><pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func timeAfter(interval time.Duration) &lt;-chan time.Time &#123;
    channel := make(chan time.Time)

    go func() &#123;
        for &#123;
            time.Sleep(interval)
            channel &lt;- time.Now()

        &#125;
    &#125;()
    return channel
&#125;

func main() &#123;
    endTime := time.Now().Add(time.Second * 10)
    for tAfter := range timeAfter(time.Second * 2) &#123;
        fmt.Println(tAfter)
        if tAfter.After(endTime) &#123;
            break // 跳出循环后，主例程完成执行，工作例程结束
        &#125;
    &#125;
&#125;
</code></pre><ul><li>close(channel) 仅限写通道，读通道无意义</li></ul><pre><code class="go">func main() &#123;
    endTime := time.Now().Add(time.Second * 10)
    for tAfter := range timeTicker(time.Second * 2) &#123;
        fmt.Println(tAfter)
        if tAfter.After(endTime) &#123;
            close(tAfter) // 仅限写通道，读通道无意义
        &#125;
    &#125;
&#125;
</code></pre><ul><li>time.Ticker.Stop()</li></ul><pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func main() &#123;
    endTime := time.Now().Add(time.Second * 10)
    ticker := time.NewTicker(time.Second * 2)

    defer ticker.Stop()
    for now := range ticker.C &#123;
        fmt.Println(now)
        if now.After(endTime) &#123;
            break
        &#125;
    &#125;
&#125;
</code></pre><h2 id="对象池-1"><a href="#对象池-1" class="headerlink" title="对象池"></a>对象池</h2><blockquote><p>定义一个worker池，由池进行执行，当任务执行完成后可以获得任务结果，再worker中可以并发执行任务，并发数量可以指定</p></blockquote><p><code>worker.go</code></p><pre><code class="go">package pool

import (
    &quot;log&quot;
    &quot;math&quot;
    &quot;sync&quot;
)

type Task func() interface&#123;&#125;

// 定义worker池

type Pool struct &#123;
    worker  int              // 定义并发数量
    tasks   *Queue           // 任务队列
    events  chan struct&#123;&#125;    // 任务通知管道
    Results chan interface&#123;&#125; // 数据管道
    wg      sync.WaitGroup   // 等待组
&#125;

// 创建worker池

func NewPool(worker int) *Pool &#123;
    return &amp;Pool&#123;
        worker:  worker,
        tasks:   NewQueue(-1),
        events:  make(chan struct&#123;&#125;, math.MaxInt32),
        Results: make(chan interface&#123;&#125;, worker*3),
    &#125;
&#125;

func (p *Pool) AddTask(task Task) &#123;
    p.tasks.Add(task)      // 向任务池添加任务
    p.events &lt;- struct&#123;&#125;&#123;&#125; // 通知执行进程
&#125;

func (p *Pool) Start() &#123;
    for i := 0; i &lt; p.worker; i++ &#123;
        p.wg.Add(1)
        go func(i int) &#123; // 开始执行并发

            for range p.events &#123; // 由于events是一个空结构体，所以无需传入参数接收，只需要遍历（忽略从管道中读取的数据）
                task, err := p.tasks.Take()
                if err != nil &#123;
                    continue
                &#125;
                log.Printf(&quot;第 %d 个例程执行 : &quot;, i)

                if e, ok := task.(Task); ok &#123; // 通过断言将空接口类型转为Task类型

                    p.Results &lt;- e() // 执行的结果放入Results管道
                &#125;
            &#125;
            p.wg.Done()
        &#125;(i)
    &#125;
&#125;
func (p *Pool) Wait() &#123;
    close(p.events)
    p.wg.Wait()
    close(p.Results)
&#125;
</code></pre><p><code>queue.go</code></p><pre><code class="go">package pool

import (
    &quot;fmt&quot;
    &quot;sync&quot;
)

const (
    defaultCap = 1024
)

// 定义队列
type Queue struct &#123;
    elements []interface&#123;&#125; //队列中的元素
    locker   sync.Mutex    //定义并发安全锁
    limit    int           // 定义队列中元素上限
&#125;

func NewQueue(limit int) *Queue &#123; // 创建队列
    return &amp;Queue&#123;
        elements: make([]interface&#123;&#125;, 0, defaultCap),
        limit:    limit,
    &#125;
&#125;

func (q *Queue) Add(e interface&#123;&#125;) error &#123; // 队列添加元素
    if q.limit != -1 &amp;&amp; len(q.elements) &gt; q.limit &#123;
        return fmt.Errorf(&quot;超出范围&quot;)
    &#125;
    q.locker.Lock()
    defer q.locker.Unlock()
    q.elements = append(q.elements, e)
    return nil
&#125;

func (q *Queue) Take() (interface&#123;&#125;, error) &#123; // 取出队列元素
    if len(q.elements) &lt;= 0 &#123;
        return nil, fmt.Errorf(&quot;内容为空&quot;)
    &#125;
    e := q.elements[0]
    q.elements = q.elements[1:]
    return e, nil
&#125;

func (q *Queue) Len() int &#123; // 查看队列元素长度
    return len(q.elements)
&#125;
</code></pre><p><code>main.go</code></p><pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;liangc.com/demo/demo9/pool&quot;
    &quot;sync&quot;
)

func main() &#123;

    var wg sync.WaitGroup

    pool := pool.NewPool(2)
    createTask := func(i int) func() interface&#123;&#125; &#123;
        return func() interface&#123;&#125; &#123;
            return i
        &#125;
    &#125;
    for i := 0; i &lt; 10; i++ &#123;
        pool.AddTask(createTask(i))
    &#125;
    pool.Start()
    wg.Add(1)
    go func() &#123;
        for result := range pool.Results &#123;
            fmt.Println(result)
        &#125;
        wg.Done()
    &#125;()

    pool.Wait()
    wg.Wait()
&#125;
</code></pre><h2 id="多线程实现统计行数"><a href="#多线程实现统计行数" class="headerlink" title="多线程实现统计行数"></a>多线程实现统计行数</h2><pre><code class="go">package pool

import (
    &quot;bufio&quot;
    &quot;fmt&quot;
    &quot;os&quot;
    &quot;strings&quot;
    &quot;sync&quot;
)

const (
    defaultCap = 1024
)

type Queue struct &#123;
    elements []int
    locker   sync.Mutex
&#125;

func NewQueue() *Queue &#123;
    return &amp;Queue&#123;
        elements: make([]int, 0, defaultCap),
    &#125;
&#125;
func (q *Queue) ReadLine(path string) error &#123;
    i := 0
    file, err := os.Open(path)
    if err != nil &#123;
        return fmt.Errorf(&quot;文件不存在&quot;)
    &#125;
    scanner := bufio.NewScanner(file)
    for scanner.Scan() &#123;
        s := scanner.Text()
        s = strings.TrimSpace(s)
        if s == &quot;&quot; || strings.HasPrefix(s, &quot;//&quot;) &#123;
            continue
        &#125;
        i++
    &#125;
    q.locker.Lock()
    defer q.locker.Unlock()
    q.elements = append(q.elements, i)
    return nil
&#125;

func (q *Queue) Take() (int, error) &#123;
    if len(q.elements) &lt;= 0 &#123;
        return 0, fmt.Errorf(&quot;内容为空&quot;)
    &#125;
    e := q.elements[0]
    q.elements = q.elements[1:]
    return e, nil
&#125;
</code></pre><pre><code class="go">package pool

import (
    &quot;math&quot;
    &quot;sync&quot;
)

type Pool struct &#123;
    worker  int
    tasks   *Queue
    Results chan int
    events  chan struct&#123;&#125;
    wg      sync.WaitGroup
&#125;

func NewPool(i int) *Pool &#123;
    return &amp;Pool&#123;
        worker:  i,
        tasks:   NewQueue(),
        Results: make(chan int, i*3),
        events:  make(chan struct&#123;&#125;, math.MaxInt32),
    &#125;
&#125;
func (p *Pool) AddTask(path string) &#123;
    err := p.tasks.ReadLine(path)
    if err != nil &#123;
        return
    &#125; // 向任务池添加任务
    p.events &lt;- struct&#123;&#125;&#123;&#125; // 通知执行进程
&#125;

func (p *Pool) Start() &#123;
    for i := 0; i &lt; p.worker; i++ &#123;
        p.wg.Add(1)
        go func(i int) &#123; // 开始执行并发
            for range p.events &#123;
                task, err := p.tasks.Take()
                if err != nil &#123;
                    continue
                &#125;
                p.Results &lt;- task
            &#125;
            p.wg.Done()
        &#125;(i)
    &#125;
&#125;
func (p *Pool) Wait() &#123;
    close(p.events)
    p.wg.Wait()
    close(p.Results)
&#125;
</code></pre><pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;io/fs&quot;
    &quot;liangc.com/object/object4/pool&quot;
    &quot;path/filepath&quot;
    &quot;sync&quot;
)

func main() &#123;
    pool := pool.NewPool(5)

    var (
        maxLine int
        wg      sync.WaitGroup
    )
    file, err := filepath.Abs(&quot;H:\\Object\\GoObject&quot;)
    if err != nil &#123;
        fmt.Println(err)
    &#125;
    filepath.Walk(file, func(path string, info fs.FileInfo, err error) error &#123;
        if filepath.Ext(path) == &quot;.go&quot; &amp;&amp; !info.IsDir() &#123;
            pool.AddTask(path)
        &#125;
        return nil
    &#125;)

    pool.Start()
    wg.Add(1)
    go func() &#123;
        for result := range pool.Results &#123;
            maxLine += result
        &#125;
        wg.Done()
    &#125;()

    pool.Wait()

    wg.Wait()

    fmt.Println(maxLine)

&#125;
</code></pre><div class="tags"><a href="/tags/Golang/" rel="tag"><i class="ic i-tag"></i> Golang</a> <a href="/tags/Golang%E5%85%A5%E9%97%A8%E8%BF%9B%E9%98%B6/" rel="tag"><i class="ic i-tag"></i> Golang入门进阶</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-12-26 19:44:05" itemprop="dateModified" datetime="2023-12-26T19:44:05+08:00">2023-12-26</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="余星酒 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="余星酒 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="余星酒 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>余星酒 <i class="ic i-at"><em>@</em></i>余星酒</li><li class="link"><strong>本文链接：</strong> <a href="http://example.com/Program/golang/%E8%BF%9B%E9%98%B6/%E5%B9%B6%E5%8F%91/" title="并发">http://example.com/Program/golang/进阶/并发/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/Program/golang/%E8%BF%9B%E9%98%B6/web%E5%BC%80%E5%8F%91/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giph47e9vtj20zk0m8x6l.jpg" title="web开发"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 进阶</span><h3>web开发</h3></a></div><div class="item right"><a href="/APT/web%E6%B8%97%E9%80%8F/CSRF/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipew8gmvyj20zk0m87wh.jpg" title="CSRF"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> web渗透</span><h3>CSRF</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">并发基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E3%80%81%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C"><span class="toc-number">1.1.</span> <span class="toc-text">顺序、并发与并行</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BE%8B%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">例程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">2.1.</span> <span class="toc-text">例程的创建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E9%99%B7%E9%98%B1"><span class="toc-number">2.1.1.</span> <span class="toc-text">闭包陷阱</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AD%89%E5%BE%85%E4%BE%8B%E7%A8%8B"><span class="toc-number">2.2.</span> <span class="toc-text">等待例程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#WaitGroup"><span class="toc-number">2.2.1.</span> <span class="toc-text">WaitGroup</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E5%AE%9E%E7%8E%B0%E7%AD%89%E5%BE%85"><span class="toc-number">2.2.2.</span> <span class="toc-text">管道实现等待</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-number">2.3.</span> <span class="toc-text">例程间通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Mutext%E4%BA%92%E6%96%A5%E9%94%81%E5%AE%9E%E7%8E%B0%E5%90%8C%E6%AD%A5"><span class="toc-number">2.3.1.</span> <span class="toc-text">Mutext互斥锁实现同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="toc-number">2.3.2.</span> <span class="toc-text">原子操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E5%87%8F%E6%93%8D%E4%BD%9C"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">增减操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%BD%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">2.3.2.2.</span> <span class="toc-text">载入操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E5%B9%B6%E4%BA%A4%E6%8D%A2-cas"><span class="toc-number">2.3.2.3.</span> <span class="toc-text">比较并交换 cas</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2"><span class="toc-number">2.3.2.4.</span> <span class="toc-text">交换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8"><span class="toc-number">2.3.2.5.</span> <span class="toc-text">存储</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#channel"><span class="toc-number">3.</span> <span class="toc-text">channel</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#channel%E5%88%9B%E5%BB%BA"><span class="toc-number">3.1.</span> <span class="toc-text">channel创建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E7%BC%93%E5%86%B2%E9%80%9A%E9%81%93"><span class="toc-number">3.1.1.</span> <span class="toc-text">无缓冲通道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E9%80%9A%E9%81%93"><span class="toc-number">3.1.2.</span> <span class="toc-text">缓冲通道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E7%AE%A1%E9%81%93"><span class="toc-number">3.1.3.</span> <span class="toc-text">读写管道</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#channel%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.2.</span> <span class="toc-text">channel运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E9%81%93%E7%9A%84%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6%E7%89%B9%E6%80%A7"><span class="toc-number">3.3.</span> <span class="toc-text">通道的发送和接收特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#channel%E9%81%8D%E5%8E%86"><span class="toc-number">3.4.</span> <span class="toc-text">channel遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#if-for"><span class="toc-number">3.4.1.</span> <span class="toc-text">if+for</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#range"><span class="toc-number">3.4.2.</span> <span class="toc-text">range</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#select-switch"><span class="toc-number">4.</span> <span class="toc-text">select&amp;switch</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#time"><span class="toc-number">5.</span> <span class="toc-text">time</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#time-After"><span class="toc-number">5.1.</span> <span class="toc-text">time.After()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#time-Tick"><span class="toc-number">5.2.</span> <span class="toc-text">time.Tick()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#time-Ticker"><span class="toc-number">5.3.</span> <span class="toc-text">time.Ticker</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#time-Timer"><span class="toc-number">5.4.</span> <span class="toc-text">time.Timer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%B1%A0"><span class="toc-number">6.</span> <span class="toc-text">对象池</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#sync-Pool"><span class="toc-number">6.1.</span> <span class="toc-text">sync.Pool</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-number">7.</span> <span class="toc-text">案例</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8WaitGroup%E5%AE%9E%E7%8E%B0%E7%BB%9F%E8%AE%A1%E8%A1%8C%E6%95%B0"><span class="toc-number">7.1.</span> <span class="toc-text">使用WaitGroup实现统计行数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%AE%A1%E9%81%93%E5%AE%9E%E7%8E%B0%E7%BB%9F%E8%AE%A1%E8%A1%8C%E6%95%B0"><span class="toc-number">7.2.</span> <span class="toc-text">使用管道实现统计行数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">7.3.</span> <span class="toc-text">实现定时器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%B1%A0-1"><span class="toc-number">7.4.</span> <span class="toc-text">对象池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E7%BB%9F%E8%AE%A1%E8%A1%8C%E6%95%B0"><span class="toc-number">7.5.</span> <span class="toc-text">多线程实现统计行数</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/Program/golang/%E8%BF%9B%E9%98%B6/%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%8F%8D%E5%B0%84/" rel="bookmark" title="接口与反射">接口与反射</a></li><li><a href="/Program/golang/%E8%BF%9B%E9%98%B6/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/" rel="bookmark" title="文件操作">文件操作</a></li><li><a href="/Program/golang/%E8%BF%9B%E9%98%B6/IO%E6%B5%81/" rel="bookmark" title="IO流">IO流</a></li><li><a href="/Program/golang/%E8%BF%9B%E9%98%B6/web%E5%BC%80%E5%8F%91/" rel="bookmark" title="web开发">web开发</a></li><li class="active"><a href="/Program/golang/%E8%BF%9B%E9%98%B6/%E5%B9%B6%E5%8F%91/" rel="bookmark" title="并发">并发</a></li><li><a href="/Program/golang/%E8%BF%9B%E9%98%B6/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" rel="bookmark" title="网络编程">网络编程</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="余星酒" data-src="/images/avatar.jpg"><p class="name" itemprop="name">余星酒</p><div class="description" itemprop="description">欢迎参观我的笔记空间 ~ 这里主要会记录一些安全相关的学习笔记 🌸</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">253</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">43</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">36</span> <span class="name">标签</span></a></div></nav><div class="social"></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/Program/golang/%E8%BF%9B%E9%98%B6/web%E5%BC%80%E5%8F%91/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/APT/web%E6%B8%97%E9%80%8F/CSRF/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/Program/" title="分类于 编程">编程</a> <i class="ic i-angle-right"></i> <a href="/categories/Program/Golang/" title="分类于 Golang">Golang</a> <i class="ic i-angle-right"></i> <a href="/categories/Program/Golang/%E5%9F%BA%E7%A1%80/" title="分类于 基础">基础</a></div><span><a href="/Program/golang/%E5%85%A5%E9%97%A8/%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C%E6%A0%87%E8%AF%86%E7%AC%A6/" title="关键字和标识符">关键字和标识符</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Network/" title="分类于 网络">网络</a> <i class="ic i-angle-right"></i> <a href="/categories/Network/%E5%8D%8E%E4%B8%BA%E9%98%B2%E7%81%AB%E5%A2%99/" title="分类于 华为防火墙">华为防火墙</a> <i class="ic i-angle-right"></i> <a href="/categories/Network/%E5%8D%8E%E4%B8%BA%E9%98%B2%E7%81%AB%E5%A2%99/%E5%AE%9E%E9%AA%8C/" title="分类于 实验">实验</a></div><span><a href="/Network/%E5%8D%8E%E4%B8%BA%E9%98%B2%E7%81%AB%E5%A2%99/%E5%AE%9E%E9%AA%8C/%E9%98%B2%E7%81%AB%E5%A2%99%E5%8F%8C%E6%9C%BA%E7%83%AD%E5%A4%87/" title="防火墙双机热备">防火墙双机热备</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/PDCERF/" title="分类于 应急响应">应急响应</a> <i class="ic i-angle-right"></i> <a href="/categories/PDCERF/Windows%E5%BA%94%E6%80%A5%E7%AC%94%E8%AE%B0/" title="分类于 Windows应急笔记">Windows应急笔记</a></div><span><a href="/PDCERF/Windows%E5%AE%9E%E6%88%98%E7%AF%87/%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92/" title="勒索病毒">勒索病毒</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Program/" title="分类于 编程">编程</a> <i class="ic i-angle-right"></i> <a href="/categories/Program/Golang/" title="分类于 Golang">Golang</a> <i class="ic i-angle-right"></i> <a href="/categories/Program/Golang/%E9%A1%B9%E7%9B%AE/" title="分类于 项目">项目</a></div><span><a href="/Program/golang/%E9%A1%B9%E7%9B%AE/TCP%E6%89%AB%E6%8F%8F%E5%99%A8%E5%92%8C%E4%BB%A3%E7%90%86/" title="TCP扫描器和代理">TCP扫描器和代理</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Network/" title="分类于 网络">网络</a> <i class="ic i-angle-right"></i> <a href="/categories/Network/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/" title="分类于 网络基础">网络基础</a> <i class="ic i-angle-right"></i> <a href="/categories/Network/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E5%AE%9E%E9%AA%8C/" title="分类于 实验">实验</a></div><span><a href="/Network/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E5%AE%9E%E9%AA%8C/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E6%8E%A5%E5%8F%A3%E5%AE%9E%E9%AA%8C/" title="交换机接口实验">交换机接口实验</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Network/" title="分类于 网络">网络</a> <i class="ic i-angle-right"></i> <a href="/categories/Network/%E5%8D%8E%E4%B8%BA%E9%98%B2%E7%81%AB%E5%A2%99/" title="分类于 华为防火墙">华为防火墙</a> <i class="ic i-angle-right"></i> <a href="/categories/Network/%E5%8D%8E%E4%B8%BA%E9%98%B2%E7%81%AB%E5%A2%99/%E5%AE%9E%E9%AA%8C/" title="分类于 实验">实验</a></div><span><a href="/Network/%E5%8D%8E%E4%B8%BA%E9%98%B2%E7%81%AB%E5%A2%99/%E5%AE%9E%E9%AA%8C/%E9%98%B2%E7%81%AB%E5%A2%99%E7%AD%96%E7%95%A5%E9%85%8D%E7%BD%AE/" title="防火墙策略配置">防火墙策略配置</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/APT/" title="分类于 渗透测试">渗透测试</a> <i class="ic i-angle-right"></i> <a href="/categories/APT/%E5%B7%A5%E5%85%B7/" title="分类于 工具">工具</a></div><span><a href="/APT/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/john/" title="john">john</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/PDCERF/" title="分类于 应急响应">应急响应</a> <i class="ic i-angle-right"></i> <a href="/categories/PDCERF/%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/" title="分类于 日志分析">日志分析</a></div><span><a href="/PDCERF/%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/Web%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/" title="Web日志分析">Web日志分析</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Program/" title="分类于 编程">编程</a> <i class="ic i-angle-right"></i> <a href="/categories/Program/Golang/" title="分类于 Golang">Golang</a> <i class="ic i-angle-right"></i> <a href="/categories/Program/Golang/%E5%B8%B8%E7%94%A8%E5%BA%93/" title="分类于 常用库">常用库</a></div><span><a href="/Program/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/time/" title="time">time</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/APT/" title="分类于 渗透测试">渗透测试</a> <i class="ic i-angle-right"></i> <a href="/categories/APT/%E9%9D%B6%E5%9C%BA/" title="分类于 靶场">靶场</a></div><span><a href="/APT/%E9%9D%B6%E5%9C%BAwp/%E9%9D%B6%E5%9C%BA/vulnhub/Empire-Lupin-One-1/" title="Empire Lupin One-1">Empire Lupin One-1</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">余星酒 @ 余星酒</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"Program/golang/进阶/并发/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->